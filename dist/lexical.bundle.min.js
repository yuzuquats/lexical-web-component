(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Lexical"] = factory();
	else
		root["Lexical"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./deps/@lexical/plain-text/LexicalPlainText.dev.js":
/*!**********************************************************!*\
  !*** ./deps/@lexical/plain-text/LexicalPlainText.dev.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar clipboard = __webpack_require__(/*! @lexical/clipboard */ \"./node_modules/@lexical/clipboard/LexicalClipboard.js\");\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.js\");\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\n\nvar lexical = __webpack_require__(/*! lexical */ \"./deps/lexical/Lexical.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Convoluted logic to make this work with Flow. Order matters.\n\nconst options = {\n  tag: 'history-merge'\n};\nconst setEditorOptions = options;\nconst updateOptions = options;\n\nfunction onCopyForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const clipboardData = event.clipboardData;\n    const selection = lexical.$getSelection();\n\n    if (selection !== null) {\n      if (clipboardData != null) {\n        const htmlString = clipboard.getHtmlContent(editor);\n\n        if (htmlString !== null) {\n          clipboardData.setData('text/html', htmlString);\n        }\n\n        clipboardData.setData('text/plain', selection.getTextContent());\n      }\n    }\n  });\n}\n\nfunction onPasteForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event.clipboardData;\n\n    if (clipboardData != null && lexical.$isRangeSelection(selection)) {\n      clipboard.$insertDataTransferForPlainText(clipboardData, selection);\n    }\n  });\n}\n\nfunction onCutForPlainText(event, editor) {\n  onCopyForPlainText(event, editor);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    }\n  });\n}\n\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n      const firstChild = root.getFirstChild();\n\n      if (firstChild === null) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = document.activeElement;\n\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, updateOptions);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, setEditorOptions);\n          break;\n        }\n\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, setEditorOptions);\n          break;\n        }\n\n      case 'function':\n        {\n          editor.update(initialEditorState, updateOptions);\n          break;\n        }\n    }\n  }\n}\n\nfunction registerPlainText(editor, initialEditorState) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TEXT_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForPlainText(dataTransfer, selection);\n      } else {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection$1 = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection$1 = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitialize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    onCopyForPlainText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    onCutForPlainText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    onPasteForPlainText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // TODO: Make drag and drop work at some point.\n\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // TODO: Make drag and drop work at some point.\n\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  initializeEditor(editor, initialEditorState);\n  return removeListener;\n}\n\nexports.registerPlainText = registerPlainText;\n\n//# sourceURL=webpack://Lexical/./deps/@lexical/plain-text/LexicalPlainText.dev.js?");

/***/ }),

/***/ "./deps/@lexical/plain-text/LexicalPlainText.js":
/*!******************************************************!*\
  !*** ./deps/@lexical/plain-text/LexicalPlainText.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst LexicalPlainText =  true ? __webpack_require__(/*! ./LexicalPlainText.dev.js */ \"./deps/@lexical/plain-text/LexicalPlainText.dev.js\") : undefined;\nmodule.exports = LexicalPlainText;\n\n//# sourceURL=webpack://Lexical/./deps/@lexical/plain-text/LexicalPlainText.js?");

/***/ }),

/***/ "./deps/lexical/Lexical.dev.js":
/*!*************************************!*\
  !*** ./deps/lexical/Lexical.dev.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nconst getSelection = () => window.getSelection();\n\nvar getDOMSelection = getSelection;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n// DOM\n\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\nconst IS_INERT = 3; // Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4; // Reconciliation\n\nconst ZERO_WIDTH_CHAR = \"\\u200b\";\nconst DOUBLE_LINE_BREAK = \"\\n\\n\";\nconst RTL = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst LTR = \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\" + \"\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C\" + \"\\uFE00-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RTL_REGEX = new RegExp(\"^[^\" + LTR + \"]*[\" + RTL + \"]\");\nconst LTR_REGEX = new RegExp(\"^[^\" + RTL + \"]*[\" + LTR + \"]\");\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT\n};\nconst TEXT_MODE_TO_TYPE = {\n  inert: IS_INERT,\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nconst CAN_USE_DOM = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nconst documentMode = CAN_USE_DOM && \"documentMode\" in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && \"InputEvent\" in window && !documentMode ? \"getTargetRanges\" in new window.InputEvent(\"input\") : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nlet keyCounter = 0;\n\nfunction generateRandomKey() {\n  return \"\" + keyCounter++;\n}\n\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n\n  return registeredNode;\n}\n\nconst scheduleMicroTask = typeof queueMicrotask === \"function\" ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\n\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  const nodeName = activeElement !== null ? activeElement.nodeName : null;\n  return !$isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) || nodeName !== \"INPUT\" && nodeName !== \"TEXTAREA\";\n}\n\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor\n    anchorDOM !== null && isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    // $FlowFixMe: internal field\n    const editor = currentNode.__lexicalEditor;\n\n    if (editor != null && !editor.isReadOnly()) {\n      return editor;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\n\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return \"rtl\";\n  }\n\n  if (LTR_REGEX.test(text)) {\n    return \"ltr\";\n  }\n\n  return null;\n}\n\nfunction $isTokenOrInertOrSegmented(node) {\n  return $isTokenOrInert(node) || node.isSegmented();\n}\n\nfunction $isTokenOrInert(node) {\n  return node.isToken() || node.isInert();\n}\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      // $FlowFixMe: this is a Text\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n\n  return format;\n}\n\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\n\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n\n  editor._cloneNotNeeded.add(key);\n\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n\n    const node = nodeMap.get(nextParentKey);\n\n    if (node === undefined) {\n      break;\n    }\n\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\nfunction removeFromParent(writableNode) {\n  const oldParent = writableNode.getParent();\n\n  if (oldParent !== null) {\n    const writableParent = oldParent.getWritable();\n    const children = writableParent.__children;\n    const index = children.indexOf(writableNode.__key);\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    internalMarkSiblingsAsDirty(writableNode);\n    children.splice(index, 1);\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\n\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\n\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\n\nfunction $getCompositionKey() {\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\n\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n\n  const node = editorState._nodeMap.get(key);\n\n  if (node === undefined) {\n    return null;\n  }\n\n  return node;\n}\n\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // $FlowFixMe: internal field\n\n  const key = dom[\"__lexicalKey_\" + editor._key];\n\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n\n  return null;\n}\n\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n\n    if (node !== null) {\n      return node;\n    }\n\n    dom = dom.parentNode;\n  }\n\n  return null;\n}\n\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\n\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(view => $getRoot().getTextContent());\n}\n\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n\n    if (editorState.isEmpty()) {\n      return;\n    }\n\n    if (type === \"root\") {\n      $getRoot().markDirty();\n      return;\n    }\n\n    const nodeMap = editorState._nodeMap;\n\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: \"history-merge\"\n  } : undefined);\n}\n\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\n\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get(\"root\" // $FlowFixMe: root is always in our Map\n  );\n}\n\nfunction $setSelection(selection) {\n  const editorState = getActiveEditorState();\n\n  if (selection !== null && Object.isFrozen(selection)) {\n    console.warn(\"$setSelection called on frozen selection object. Ensure selection is cloned before passing in.\");\n  }\n\n  editorState._selection = selection;\n}\n\nfunction $flushMutations$1() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\n\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n\n    if (dom === rootElement) {\n      return $getNodeByKey(\"root\");\n    }\n\n    return null;\n  }\n\n  return $getNodeByKey(nodeKey);\n}\n\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM(dom, editor) {\n  // Note that node here refers to a DOM Node, not an Lexical Node\n  let node = dom;\n\n  while (node != null) {\n    const key = node[\"__lexicalKey_\" + editor._key]; // $FlowFixMe: internal field\n\n    if (key !== undefined) {\n      return key;\n    }\n\n    node = node.parentNode;\n  }\n\n  return null;\n}\n\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\n\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n\n  return editorsToPropagate;\n}\n\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, \"\").substr(0, 5);\n}\n\nfunction $updateSelectedTextFromDOM(editor, compositionEndEvent) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection();\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n\n  if (anchorNode !== null && anchorNode.nodeType === DOM_TEXT_TYPE) {\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n\n    if ($isTextNode(node)) {\n      let textContent = anchorNode.nodeValue;\n      const data = compositionEndEvent !== null && compositionEndEvent.data; // Data is intentionally truthy, as we check for boolean, null and empty string.\n\n      if (textContent === ZERO_WIDTH_CHAR && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, compositionEndEvent !== null);\n    }\n  }\n}\n\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === ZERO_WIDTH_CHAR) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === \"\") {\n        $setCompositionKey(null);\n\n        if (!IS_SAFARI && !IS_IOS) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n\n        return;\n      }\n\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n\n      if ($isTokenOrInert(node) || $getCompositionKey() !== null && !isComposing || // Check if character was added at the start, and we need\n      // to clear this input from occuring as that action wasn't\n      // permitted.\n      parent !== null && $isRangeSelection(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {\n        node.markDirty();\n        return;\n      }\n\n      const selection = $getSelection();\n\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  const shouldInsertTextBefore = offset === 0 && (!node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken);\n  const shouldInsertTextAfter = node.getTextContentSize() === offset && (!node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken);\n  return shouldInsertTextBefore || shouldInsertTextAfter;\n}\n\nfunction $shouldPreventDefaultAndInsertText(selection, text, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const domSelection = getDOMSelection();\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = getActiveEditor().getElementByKey(anchorKey);\n  return anchorKey !== focus.key || // If we're working with a non-text node.\n  !$isTextNode(anchorNode) || // If we're working with a range that is not during composition.\n  anchor.offset !== focus.offset && !anchorNode.isComposing() || // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  (isBeforeInput || anchorNode.isDirty()) && text.length > 1 || // If the DOM selection element is not the same as the backing node\n  backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\n\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\n\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\n\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\n\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\n\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\n\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\n\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\n\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\n\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\n\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\n\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isBackspace(keyCode);\n}\n\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isDelete(keyCode);\n}\n\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\n\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\n\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\n\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\n\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\n\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\n\nfunction isMoveBackward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\n\nfunction isMoveForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\n\nfunction isMoveUp(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\n\nfunction isMoveDown(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\n\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\n\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n\n  return ctrlKey;\n}\n\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\n\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\n\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\n\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\n\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === \"string\") {\n    const classNamesArr = classNames.split(\" \");\n    classNamesTheme[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n\n  return classNames;\n}\n\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n\n  if (!mutatedNodesByType.has(nodeKey)) {\n    mutatedNodesByType.set(nodeKey, mutation);\n  }\n}\n\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n\n  return nodesOfType;\n}\n\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nfunction $getDecoratorNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n\n  if (focus.type === \"element\") {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n\n      return possibleNode;\n    }\n  }\n\n  return null;\n}\n\nfunction isFirefoxClipboardEvents() {\n  const event = window.event;\n  const inputType = event && event.inputType;\n  return inputType === \"insertFromPaste\" || inputType === \"insertFromPasteAsQuotation\";\n}\n\nfunction dispatchCommand(editor, type, payload) {\n  return triggerCommandListeners(editor, type, payload);\n}\n\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {\n  const children = node.__children;\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    const childKey = children[i];\n    const child = nodeMap.get(childKey);\n\n    if (child !== undefined && child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n\n      nodeMap.delete(childKey);\n    }\n  }\n}\n\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n\n      nodeMap.delete(nodeKey);\n    }\n  }\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n\n        nodeMap.delete(nodeKey);\n      }\n    }\n  }\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\n\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n\n  if (node.__text === \"\" && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n\n  let previousNode;\n\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === \"\") {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n\n  let nextNode;\n\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === \"\") {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction $createNodeFromParse(parsedNode, parsedNodeMap) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  return internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, null);\n}\n\nfunction internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, parentKey, state = {\n  originalSelection: null\n}) {\n  const nodeType = parsedNode.__type;\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`createNodeFromParse: type \"${nodeType}\" + not found`);\n    }\n  } // Check for properties that are editors\n\n\n  for (const property in parsedNode) {\n    const value = parsedNode[property];\n\n    if (value != null && typeof value === \"object\") {\n      const parsedEditorState = value.editorState;\n\n      if (parsedEditorState != null) {\n        const nestedEditor = createEditor();\n        nestedEditor._nodes = editor._nodes;\n        nestedEditor._parentEditor = editor._parentEditor;\n        nestedEditor._pendingEditorState = parseEditorState(parsedEditorState, nestedEditor);\n        parsedNode[property] = nestedEditor;\n      }\n    }\n  }\n\n  const NodeKlass = registeredNode.klass;\n  const parsedKey = parsedNode.__key; // We set the parsedKey to undefined before calling clone() so that\n  // we get a new random key assigned.\n\n  parsedNode.__key = undefined;\n  const node = NodeKlass.clone(parsedNode);\n  parsedNode.__key = parsedKey;\n  const key = node.__key;\n\n  if ($isRootNode(node)) {\n    const editorState = getActiveEditorState();\n\n    editorState._nodeMap.set(\"root\", node);\n  }\n\n  node.__parent = parentKey; // We will need to recursively handle the children in the case\n  // of a ElementNode.\n\n  if ($isElementNode(node)) {\n    const children = parsedNode.__children;\n\n    for (let i = 0; i < children.length; i++) {\n      const childKey = children[i];\n      const parsedChild = parsedNodeMap.get(childKey);\n\n      if (parsedChild !== undefined) {\n        const child = internalCreateNodeFromParse(parsedChild, parsedNodeMap, editor, key, state);\n        const newChildKey = child.__key;\n\n        node.__children.push(newChildKey);\n      }\n    }\n\n    node.__indent = parsedNode.__indent;\n    node.__format = parsedNode.__format;\n    node.__dir = parsedNode.__dir;\n  } else if ($isTextNode(node)) {\n    node.__format = parsedNode.__format;\n    node.__style = parsedNode.__style;\n    node.__mode = parsedNode.__mode;\n    node.__detail = parsedNode.__detail;\n    node.__marks = parsedNode.__marks;\n  } // The selection might refer to an old node whose key has changed. Produce a\n  // new selection record with the old keys mapped to the new ones.\n\n\n  const originalSelection = state != null ? state.originalSelection : undefined;\n\n  if (originalSelection != null) {\n    let remappedSelection = state.remappedSelection;\n\n    if (originalSelection.type === \"range\") {\n      const anchor = originalSelection.anchor;\n      const focus = originalSelection.focus;\n\n      if (remappedSelection == null && (parsedKey === anchor.key || parsedKey === focus.key)) {\n        state.remappedSelection = remappedSelection = {\n          anchor: { ...anchor\n          },\n          focus: { ...focus\n          },\n          type: \"range\"\n        };\n      }\n\n      if (remappedSelection != null && remappedSelection.type === \"range\") {\n        if (parsedKey === anchor.key) {\n          remappedSelection.anchor.key = key;\n        }\n\n        if (parsedKey === focus.key) {\n          remappedSelection.focus.key = key;\n        }\n      }\n    } else if (originalSelection.type === \"node\") {\n      const nodes = originalSelection.nodes;\n      const indexOf = nodes.indexOf(parsedKey);\n\n      if (indexOf !== -1) {\n        if (remappedSelection == null) {\n          state.remappedSelection = remappedSelection = {\n            nodes: [...nodes],\n            type: \"node\"\n          };\n        }\n\n        if (remappedSelection.type === \"node\") {\n          remappedSelection.nodes.splice(indexOf, 1, key);\n        }\n      }\n    } else if (originalSelection.type === \"grid\") {\n      const gridKey = originalSelection.gridKey;\n      const anchorCellKey = originalSelection.anchor.key;\n      const focusCellKey = originalSelection.focus.key;\n\n      if (remappedSelection == null && (gridKey === parsedKey || gridKey === anchorCellKey || gridKey === focusCellKey)) {\n        state.remappedSelection = remappedSelection = { ...originalSelection,\n          type: \"grid\"\n        };\n      }\n\n      if (remappedSelection != null && remappedSelection.type === \"grid\") {\n        if (gridKey === parsedKey) {\n          remappedSelection.gridKey = key;\n        }\n\n        if (anchorCellKey === parsedKey) {\n          remappedSelection.anchor.key = key;\n        }\n\n        if (focusCellKey === parsedKey) {\n          remappedSelection.focus.key = key;\n        }\n      }\n    }\n  }\n\n  return node;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction createCommand() {\n  // $FlowFixMe: avoid freezing the object for perf reasons\n  return {};\n}\n\nconst SELECTION_CHANGE_COMMAND = createCommand();\nconst CLICK_COMMAND = createCommand();\nconst DELETE_CHARACTER_COMMAND = createCommand();\nconst INSERT_LINE_BREAK_COMMAND = createCommand();\nconst INSERT_PARAGRAPH_COMMAND = createCommand();\nconst INSERT_TEXT_COMMAND = createCommand();\nconst PASTE_COMMAND = createCommand();\nconst REMOVE_TEXT_COMMAND = createCommand();\nconst DELETE_WORD_COMMAND = createCommand();\nconst DELETE_LINE_COMMAND = createCommand();\nconst FORMAT_TEXT_COMMAND = createCommand();\nconst UNDO_COMMAND = createCommand();\nconst REDO_COMMAND = createCommand();\nconst KEY_ARROW_RIGHT_COMMAND = createCommand();\nconst KEY_ARROW_LEFT_COMMAND = createCommand();\nconst KEY_ARROW_UP_COMMAND = createCommand();\nconst KEY_ARROW_DOWN_COMMAND = createCommand();\nconst KEY_ENTER_COMMAND = createCommand();\nconst KEY_BACKSPACE_COMMAND = createCommand();\nconst KEY_ESCAPE_COMMAND = createCommand();\nconst KEY_DELETE_COMMAND = createCommand();\nconst KEY_TAB_COMMAND = createCommand();\nconst INDENT_CONTENT_COMMAND = createCommand();\nconst OUTDENT_CONTENT_COMMAND = createCommand();\nconst DROP_COMMAND = createCommand();\nconst FORMAT_ELEMENT_COMMAND = createCommand();\nconst DRAGSTART_COMMAND = createCommand();\nconst DRAGEND_COMMAND = createCommand();\nconst COPY_COMMAND = createCommand();\nconst CUT_COMMAND = createCommand();\nconst CLEAR_EDITOR_COMMAND = createCommand();\nconst CLEAR_HISTORY_COMMAND = createCommand();\nconst CAN_REDO_COMMAND = createCommand();\nconst CAN_UNDO_COMMAND = createCommand();\nconst FOCUS_COMMAND = createCommand();\nconst BLUR_COMMAND = createCommand();\nconst KEY_MODIFIER_COMMAND = createCommand();\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [// $FlowIgnore bad event inheritance\n[\"keydown\", onKeyDown], // $FlowIgnore bad event inheritance\n[\"compositionstart\", onCompositionStart], // $FlowIgnore bad event inheritance\n[\"compositionend\", onCompositionEnd], // $FlowIgnore bad event inheritance\n[\"input\", onInput], // $FlowIgnore bad event inheritance\n[\"click\", onClick], [\"cut\", PASS_THROUGH_COMMAND], [\"copy\", PASS_THROUGH_COMMAND], [\"dragstart\", PASS_THROUGH_COMMAND], [\"paste\", PASS_THROUGH_COMMAND], [\"focus\", PASS_THROUGH_COMMAND], [\"blur\", PASS_THROUGH_COMMAND]];\n\nif (CAN_USE_BEFORE_INPUT) {\n  // $FlowIgnore bad event inheritance\n  rootElementEvents.push([\"beforeinput\", onBeforeInput]);\n} else {\n  rootElementEvents.push([\"drop\", PASS_THROUGH_COMMAND]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromReconcile = false;\nlet isInsertLineBreak = false;\nlet collapsedSelectionFormat = [0, 0, \"root\", 0];\n\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\n\nfunction onSelectionChange(domSelection, editor, isActive) {\n  if (isSelectionChangeFromReconcile) {\n    isSelectionChangeFromReconcile = false;\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    } = domSelection; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n\n    if (shouldSkipSelectionChange(anchorNode, anchorOffset) && shouldSkipSelectionChange(focusNode, focusOffset)) {\n      return;\n    }\n  }\n\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === \"Range\") {\n          selection.dirty = true;\n        } // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n\n\n        const currentTimeStamp = window.event.timeStamp;\n        const [lastFormat, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n        } else {\n          if (anchor.type === \"text\") {\n            selection.format = anchorNode.getFormat();\n          } else if (anchor.type === \"element\") {\n            selection.format = 0;\n          }\n        }\n      } else {\n        const focus = selection.focus;\n        const focusNode = focus.getNode();\n        let combinedFormat = 0;\n\n        if (anchor.type === \"text\") {\n          combinedFormat |= anchorNode.getFormat();\n        }\n\n        if (focus.type === \"text\" && !anchorNode.is(focusNode)) {\n          combinedFormat |= focusNode.getFormat();\n        }\n\n        selection.format = combinedFormat;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n\n      if (anchor.type === \"element\" && anchor.offset === 0 && selection.isCollapsed() && $getRoot().getChildrenSize() === 1 && anchor.getNode().getTopLevelElementOrThrow().isEmpty()) {\n        const lastSelection = $getPreviousSelection();\n\n        if (lastSelection !== null && selection.is(lastSelection)) {\n          getDOMSelection().removeAllRanges();\n          selection.dirty = true;\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction $applyTargetRange(selection, event) {\n  if (event.getTargetRanges) {\n    const targetRange = event.getTargetRanges()[0];\n\n    if (targetRange) {\n      selection.applyDOMRange(targetRange);\n    }\n  }\n}\n\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrInert(anchorNode) || !$isTokenOrInert(focusNode);\n}\n\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType; // We let the browser do its own thing for composition.\n\n  if (inputType === \"deleteCompositionText\" || // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents()) {\n    return;\n  } else if (inputType === \"insertCompositionText\") {\n    // This logic handles insertion of text between different\n    // format text types. We have to detect a change in type\n    // during composition and see if the previous text contains\n    // part of the composed text to work out the actual text that\n    // we need to insert.\n    const composedText = event.data;\n\n    if (composedText) {\n      updateEditor(editor, () => {\n        const selection = $getSelection();\n\n        if ($isRangeSelection(selection)) {\n          const anchor = selection.anchor;\n          const node = anchor.getNode();\n          const prevNode = node.getPreviousSibling();\n\n          if (anchor.offset === 0 && $isTextNode(node) && $isTextNode(prevNode) && node.getTextContent() === \" \" && prevNode.getFormat() !== selection.format) {\n            const prevTextContent = prevNode.getTextContent();\n\n            if (composedText.indexOf(prevTextContent) === 0) {\n              const insertedText = composedText.slice(prevTextContent.length);\n              dispatchCommand(editor, INSERT_TEXT_COMMAND, insertedText);\n              setTimeout(() => {\n                updateEditor(editor, () => {\n                  node.select();\n                });\n              }, ANDROID_COMPOSITION_LATENCY);\n            }\n          }\n        }\n      });\n    }\n\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (inputType === \"deleteContentBackward\") {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n\n        $setSelection(prevSelection.clone());\n      } // Used for Android\n\n\n      $setCompositionKey(null);\n      event.preventDefault();\n      lastKeyDownTimeStamp = 0;\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true); // Fixes an Android bug where selection flickers when backspacing\n\n      setTimeout(() => {\n        editor.update(() => {\n          $setCompositionKey(null);\n        });\n      }, ANDROID_COMPOSITION_LATENCY);\n      return;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    const data = event.data;\n\n    if (!selection.dirty && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {\n      $applyTargetRange(selection, event);\n    }\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === \"insertText\") {\n      if (data === \"\\n\") {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData(\"text/plain\");\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_TEXT_COMMAND, data);\n      }\n\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n\n    event.preventDefault();\n\n    switch (inputType) {\n      case \"insertFromYank\":\n      case \"insertFromDrop\":\n      case \"insertReplacementText\":\n        {\n          dispatchCommand(editor, INSERT_TEXT_COMMAND, event);\n          break;\n        }\n\n      case \"insertFromComposition\":\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_TEXT_COMMAND, event);\n          break;\n        }\n\n      case \"insertLineBreak\":\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND);\n          break;\n        }\n\n      case \"insertParagraph\":\n        {\n          // Used for Android\n          $setCompositionKey(null); // Some browsers do not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n\n          if (isInsertLineBreak) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND);\n          }\n\n          break;\n        }\n\n      case \"insertFromPaste\":\n      case \"insertFromPasteAsQuotation\":\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n\n      case \"deleteByComposition\":\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND);\n          }\n\n          break;\n        }\n\n      case \"deleteByDrag\":\n      case \"deleteByCut\":\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND);\n          break;\n        }\n\n      case \"deleteContent\":\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n\n      case \"deleteWordBackward\":\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n\n      case \"deleteWordForward\":\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n\n      case \"deleteHardLineBackward\":\n      case \"deleteSoftLineBackward\":\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n\n      case \"deleteContentForward\":\n      case \"deleteHardLineForward\":\n      case \"deleteSoftLineForward\":\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n\n      case \"formatStrikeThrough\":\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"strikethrough\");\n          break;\n        }\n\n      case \"formatBold\":\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"bold\");\n          break;\n        }\n\n      case \"formatItalic\":\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"italic\");\n          break;\n        }\n\n      case \"formatUnderline\":\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"underline\");\n          break;\n        }\n\n      case \"historyUndo\":\n        {\n          dispatchCommand(editor, UNDO_COMMAND);\n          break;\n        }\n\n      case \"historyRedo\":\n        {\n          dispatchCommand(editor, REDO_COMMAND);\n          break;\n        }\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, data, false)) {\n      dispatchCommand(editor, INSERT_TEXT_COMMAND, data); // For Android\n\n      if (editor._compositionKey !== null) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      $updateSelectedTextFromDOM(editor, null);\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n\n    $flushMutations$1();\n  });\n}\n\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      $setCompositionKey(anchor.key);\n\n      if ( // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      IS_FIREFOX && anchor.type === \"element\" || !selection.isCollapsed() || selection.anchor.getNode().getFormat() !== selection.format) {\n        // We insert an empty space, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, INSERT_TEXT_COMMAND, \" \");\n      }\n    }\n  });\n}\n\nfunction onCompositionEnd(event, editor) {\n  updateEditor(editor, () => {\n    const compositionKey = editor._compositionKey;\n    $setCompositionKey(null);\n    const data = event.data; // Handle termination of composition.\n\n    if (compositionKey !== null && data != null) {\n      // It can sometimes move to an adjacent DOM node when backspacing.\n      // So check for the empty case.\n      if (data === \"\") {\n        const node = $getNodeByKey(compositionKey);\n        const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n        if (textNode !== null && $isTextNode(node)) {\n          $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n        }\n\n        return;\n      } else if (data[data.length - 1] === \"\\n\") {\n        const selection = $getSelection();\n\n        if ($isRangeSelection(selection)) {\n          // If the last character is a line break, we also need to insert\n          // a line break.\n          const focus = selection.focus;\n          selection.anchor.set(focus.key, focus.offset, focus.type);\n          dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n          return;\n        }\n      }\n    }\n\n    $updateSelectedTextFromDOM(editor, event);\n  });\n}\n\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n\n  if (isMoveForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveUp(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"bold\");\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"underline\");\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, \"italic\");\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND);\n  }\n\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\n\nfunction getRootElementRemoveHandles(rootElement) {\n  // $FlowFixMe: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = []; // $FlowFixMe: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\n\nconst activeNestedEditorsMap = new Map();\n\nfunction onDocumentSelectionChange(event) {\n  const selection = getDOMSelection();\n  const nextActiveEditor = getNearestEditorFromDOMNode(selection.anchorNode);\n\n  if (nextActiveEditor === null) {\n    return;\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(selection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(selection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener(\"selectionchange\", onDocumentSelectionChange);\n  }\n\n  rootElementsRegistered++; // $FlowFixMe: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === \"function\" ? event => {\n      if (!editor.isReadOnly()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (!editor.isReadOnly()) {\n        switch (eventName) {\n          case \"cut\":\n            return dispatchCommand(editor, CUT_COMMAND, event);\n\n          case \"copy\":\n            return dispatchCommand(editor, COPY_COMMAND, event);\n\n          case \"paste\":\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n\n          case \"dragstart\":\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n\n          case \"dragend\":\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n\n          case \"focus\":\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n\n          case \"blur\":\n            return dispatchCommand(editor, BLUR_COMMAND, event);\n\n          case \"drop\":\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\n\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener(\"selectionchange\", onDocumentSelectionChange);\n    }\n  } // $FlowFixMe: internal field\n\n\n  const editor = rootElement.__lexicalEditor;\n\n  if (editor != null) {\n    cleanActiveNestedEditorsMap(editor); // $FlowFixMe: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // $FlowFixMe: internal field\n\n\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nfunction markSelectionChangeFromReconcile() {\n  isSelectionChangeFromReconcile = true;\n}\n\nfunction markCollapsedSelectionFormat(format, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, offset, key, timeStamp];\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nlet subTreeTextContent = \"\";\nlet subTreeDirectionedTextContent = \"\";\nlet editorTextContent = \"\";\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\n\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    parentDOM.removeChild(dom);\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = node.__children;\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, \"destroyed\");\n  }\n}\n\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty(\"text-align\", value);\n}\n\nfunction setElementIndent(dom, indent) {\n  dom.style.setProperty(\"padding-inline-start\", indent === 0 ? \"\" : indent * 20 + \"px\");\n}\n\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, \"\");\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, \"left\");\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, \"center\");\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, \"right\");\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, \"justify\");\n  }\n}\n\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute(\"data-lexical-text\", \"true\");\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute(\"data-lexical-decorator\", \"true\");\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n\n    const children = node.__children;\n    const childrenLength = children.length;\n\n    if (childrenLength !== 0) {\n      const endIndex = childrenLength - 1;\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n\n    reconcileElementTerminatingLineBreak(null, children, dom);\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n\n      dom.contentEditable = \"false\";\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      if (node.isInert()) {\n        const domStyle = dom.style;\n        domStyle.pointerEvents = \"none\";\n        domStyle.userSelect = \"none\";\n        dom.contentEditable = \"false\"; // To support Safari\n\n        domStyle.setProperty(\"-webkit-user-select\", \"none\");\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // $FlowFixMe: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, \"created\");\n  return dom;\n}\n\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = \"\";\n  createChildren(children, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\n\nfunction createChildren(children, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = \"\";\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  } // $FlowFixMe: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(children, nodeMap) {\n  const childKey = children[children.length - 1];\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node);\n} // If we end an element with a LinkBreakNode, then we need to add an additonal <br>\n\n\nfunction reconcileElementTerminatingLineBreak(prevChildren, nextChildren, dom) {\n  const prevLineBreak = prevChildren !== null && (prevChildren.length === 0 || isLastChildLineBreakOrDecorator(prevChildren, activePrevNodeMap));\n  const nextLineBreak = nextChildren !== null && (nextChildren.length === 0 || isLastChildLineBreakOrDecorator(nextChildren, activeNextNodeMap));\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // $FlowFixMe: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        dom.removeChild(element);\n      } // $FlowFixMe: internal field\n\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement(\"br\"); // $FlowFixMe: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent; // $FlowFixMe: internal field // $FlowFixMe: internal field\n\n  const previousDirection = dom.__lexicalDir;\n\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === \"\";\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === \"string\") {\n          const classNamesArr = previousDirectionTheme.split(\" \"); // $FlowFixMe: intentional\n\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // $FlowFixMe: intentional\n\n\n        classList.remove(...previousDirectionTheme);\n      }\n\n      if (direction === null || hasEmptyDirectionedTextContent && direction === \"ltr\") {\n        // Remove direction\n        dom.removeAttribute(\"dir\");\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === \"string\") {\n            const classNamesArr = nextDirectionTheme.split(\" \"); // $FlowFixMe: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n\n          classList.add(...nextDirectionTheme);\n        } // Update direction\n\n\n        dom.dir = direction;\n      }\n\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n\n    activeTextDirection = direction; // $FlowFixMe: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // $FlowFixMe: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\n\nfunction reconcileChildrenWithDirection(prevChildren, nextChildren, element, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = \"\";\n  reconcileChildren(element, prevChildren, nextChildren, dom);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\n\nfunction reconcileChildren(element, prevChildren, nextChildren, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = \"\";\n  const prevChildrenLength = prevChildren.length;\n  const nextChildrenLength = nextChildren.length;\n\n  if (prevChildrenLength === 1 && nextChildrenLength === 1) {\n    const prevChildKey = prevChildren[0];\n    const nextChildKey = nextChildren[0];\n\n    if (prevChildKey === nextChildKey) {\n      reconcileNode(prevChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevChildKey);\n      const replacementDOM = createNode(nextChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevChildKey, null);\n    }\n  } else if (prevChildrenLength === 0) {\n    if (nextChildrenLength !== 0) {\n      createChildren(nextChildren, 0, nextChildrenLength - 1, dom, null);\n    }\n  } else if (nextChildrenLength === 0) {\n    if (prevChildrenLength !== 0) {\n      // $FlowFixMe: internal field\n      const lexicalLineBreak = dom.__lexicalLineBreak;\n      const canUseFastPath = lexicalLineBreak == null;\n      destroyChildren(prevChildren, 0, prevChildrenLength - 1, canUseFastPath ? null : dom);\n\n      if (canUseFastPath) {\n        // Fast path for removing DOM nodes\n        dom.textContent = \"\";\n      }\n    }\n  } else {\n    reconcileNodeChildren(prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, element, dom);\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // $FlowFixMe: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // $FlowFixMe: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // $FlowFixMe: internal field\n\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  }\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, \"updated\");\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n\n    const prevChildren = prevNode.__children;\n    const nextChildren = nextNode.__children;\n    const childrenAreDifferent = prevChildren !== nextChildren;\n\n    if (childrenAreDifferent || isDirty) {\n      reconcileChildrenWithDirection(prevChildren, nextChildren, nextNode, dom);\n\n      if (!$isRootNode(nextNode)) {\n        reconcileElementTerminatingLineBreak(prevChildren, nextChildren, dom);\n      }\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n\n      subTreeTextContent += text;\n      editorTextContent += text;\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\n\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element) {\n  // $FlowFixMe: firstChild is always null or a Node\n  return element.firstChild;\n}\n\nfunction getNextSibling(element) {\n  // $FlowFixMe: nextSibling is always null or a Node\n  return element.nextSibling;\n}\n\nfunction reconcileNodeChildren(prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, element, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  subTreeTextContent = \"\";\n  editorTextContent = \"\";\n  subTreeDirectionedTextContent = \"\"; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode(\"root\", null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // $FlowFixMe\n\n  activeEditor$1 = undefined; // $FlowFixMe\n\n  activeEditorNodes = undefined; // $FlowFixMe\n\n  activeDirtyElements = undefined; // $FlowFixMe\n\n  activeDirtyLeaves = undefined; // $FlowFixMe\n\n  activePrevNodeMap = undefined; // $FlowFixMe\n\n  activeNextNodeMap = undefined; // $FlowFixMe\n\n  activeEditorConfig = undefined; // $FlowFixMe\n\n  activePrevKeyToDOMMap = undefined; // $FlowFixMe\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\n\nfunction updateEditorState(rootElement, currentEditorState, pendingEditorState, currentSelection, pendingSelection, needsUpdate, editor) {\n  const observer = editor._observer;\n  let reconcileMutatedNodes = null;\n\n  if (needsUpdate && observer !== null) {\n    const dirtyType = editor._dirtyType;\n    const dirtyElements = editor._dirtyElements;\n    const dirtyLeaves = editor._dirtyLeaves;\n    observer.disconnect();\n\n    try {\n      reconcileMutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } finally {\n      observer.observe(rootElement, {\n        characterData: true,\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n\n  const domSelection = getDOMSelection();\n\n  if (!editor._readOnly && domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    reconcileSelection(currentSelection, pendingSelection, editor, domSelection);\n  }\n\n  return reconcileMutatedNodes;\n}\n\nfunction scrollIntoViewIfNeeded(editor, node, rootElement) {\n  const element = node.nodeType === DOM_TEXT_TYPE ? node.parentNode : node; // $FlowFixMe: this is valid, as we are checking the nodeType\n\n  if (element !== null) {\n    const rect = element.getBoundingClientRect();\n\n    if (rect.bottom > window.innerHeight) {\n      element.scrollIntoView(false);\n    } else if (rect.top < 0) {\n      element.scrollIntoView();\n    } else if (rootElement) {\n      const rootRect = rootElement.getBoundingClientRect();\n\n      if (rect.bottom > rootRect.bottom) {\n        element.scrollIntoView(false);\n      } else if (rect.top < rootRect.top) {\n        element.scrollIntoView();\n      }\n    }\n\n    editor._updateTags.add(\"scroll-into-view\");\n  }\n}\n\nfunction reconcileSelection(prevSelection, nextSelection, editor, domSelection) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n  const rootElement = editor._rootElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (editor._updateTags.has(\"collaboration\") && activeElement !== rootElement) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  {\n    // Freeze the selection in DEV to prevent accidental mutations\n    Object.freeze(anchor);\n    Object.freeze(focus);\n    Object.freeze(nextSelection);\n  }\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatChanged = false;\n\n  if (anchor.type === \"text\") {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    anchorFormatChanged = anchor.getNode().getFormat() !== nextFormat;\n  }\n\n  if (focus.type === \"text\") {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n\n  if (isCollapsed && (prevSelection === null || anchorFormatChanged || prevSelection.format !== nextFormat)) {\n    markCollapsedSelectionFormat(nextFormat, nextAnchorOffset, anchorKey, performance.now());\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === \"Range\" && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    } // In Safari/iOS if we have selection on an element, then we also\n    // need to additionally set the DOM selection, otherwise a selectionchange\n    // event will not fire.\n\n\n    if (!(IS_IOS || IS_SAFARI) || anchor.type !== \"element\") {\n      return;\n    }\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n\n    if (nextSelection.isCollapsed() && rootElement === activeElement) {\n      scrollIntoViewIfNeeded(editor, nextAnchorNode, rootElement);\n    }\n\n    markSelectionChangeFromReconcile();\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n}\n\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // $FlowFixMe: internal field\n\n  dom[\"__lexicalKey_\" + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key \"${key}\"`);\n    }\n  }\n\n  return element;\n}\n\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key \"${key}\"`);\n    }\n  }\n\n  return element;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\n\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode;\n}\n\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\n\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\n\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n\n  return activeEditorState;\n}\n\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n\n  return activeEditor;\n}\n\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined && // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\n\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtress we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n\n      if (nodeKey === \"root\" || !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\nfunction parseEditorState(parsedEditorState, editor) {\n  const nodeMap = new Map();\n  const editorState = new EditorState(nodeMap);\n  const nodeParserState = {\n    originalSelection: parsedEditorState._selection\n  };\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const parsedNodeMap = new Map(parsedEditorState._nodeMap); // $FlowFixMe: root always exists in Map\n\n    const parsedRoot = parsedNodeMap.get(\"root\");\n    internalCreateNodeFromParse(parsedRoot, parsedNodeMap, editor, null,\n    /* parentKey */\n    nodeParserState);\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  editorState._selection = internalCreateSelectionFromParse(nodeParserState.remappedSelection || nodeParserState.originalSelection);\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap; // $FlowFixMe: this is allowed\n\n  nodeMap.set = () => {\n    throw new Error(\"Cannot call set() on a frozen Lexical node map\");\n  }; // $FlowFixMe: this is allowed\n\n\n  nodeMap.clear = () => {\n    throw new Error(\"Cannot call clear() on a frozen Lexical node map\");\n  }; // $FlowFixMe: this is allowed\n\n\n  nodeMap.delete = () => {\n    throw new Error(\"Cannot call delete() on a frozen Lexical node map\");\n  };\n}\n\nfunction commitPendingUpdates(editor) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n\n  if (rootElement === null || pendingEditorState === null) {\n    return;\n  }\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditor = editor;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false; // We don't want updates to sync block the reconcilation.\n\n  editor._updating = true;\n\n  try {\n    const mutatedNodes = updateEditorState(rootElement, currentEditorState, pendingEditorState, currentSelection, pendingSelection, needsUpdate, editor);\n\n    if (mutatedNodes !== null) {\n      triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes);\n    }\n  } catch (error) {\n    // Report errors\n    editor._onError(error); // Reset editor and restore incoming editor state to the DOM\n\n\n    if (!isAttemptingToRecoverFromReconcilerError) {\n      resetEditor(editor, null, rootElement, pendingEditorState);\n      initMutationObserver(editor);\n      editor._dirtyType = FULL_RECONCILE;\n      isAttemptingToRecoverFromReconcilerError = true;\n      commitPendingUpdates(editor);\n      isAttemptingToRecoverFromReconcilerError = false;\n    }\n\n    return;\n  } finally {\n    editor._updating = previouslyUpdating;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  pendingEditorState._readOnly = true;\n  {\n    handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n  const pendingDecorators = editor._pendingDecorators;\n\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners(\"decorator\", editor, true, pendingDecorators);\n  }\n\n  triggerTextContentListeners(editor, currentEditorState, pendingEditorState);\n  triggerListeners(\"update\", editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor);\n  triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners(\"textcontent\", editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes) {\n  const listeners = editor._listeners.mutation;\n  listeners.forEach((klass, listener) => {\n    const mutatedNodesByType = mutatedNodes.get(klass);\n\n    if (mutatedNodesByType === undefined) {\n      return;\n    }\n\n    listener(mutatedNodesByType);\n  });\n}\n\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, // $FlowFixMe: needs refining\n...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n\n    for (let i = 0; i < listeners.length; i++) {\n      listeners[i](...payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\n\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listeners = listenerInPriorityOrder[i];\n\n        if (listeners !== undefined) {\n          for (const listener of listeners) {\n            // $FlowFixMe[missing-type-arg]\n            if (listener(payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const [updateFn, options] = queuedUpdates.shift();\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(editor) {\n  const deferred = editor._deferred;\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const [nextUpdateFn, options] = queuedUpdates.shift();\n    let onUpdate;\n    let tag;\n\n    if (options !== undefined) {\n      onUpdate = options.onUpdate;\n      tag = options.tag;\n\n      if (options.skipTransforms) {\n        skipTransforms = true;\n      }\n\n      if (onUpdate) {\n        editor._deferred.push(onUpdate);\n      }\n\n      if (tag) {\n        editor._updateTags.add(tag);\n      }\n    }\n\n    nextUpdateFn();\n  }\n\n  return skipTransforms;\n}\n\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(currentEditorState);\n    editorStateWasCloned = true;\n  }\n\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      pendingEditorState._selection = internalCreateSelection(editor);\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    editor._onError(error); // Restore existing editor state to the DOM\n\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\n\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener() {\n  if (lastTextEntryTimeStamp === 0) {\n    window.addEventListener(\"textInput\", updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(dom, target, editor) {\n  return (// $FlowFixMe: internal field\n    target.__lexicalLineBreak === dom || // $FlowFixMe: internal field\n    dom[\"__lexicalKey_\" + editor._key] !== undefined\n  );\n}\n\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection();\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n  $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n}\n\nfunction $flushMutations(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current edtior state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = \"\";\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n\n        if ($isDecoratorNode(targetNode)) {\n          continue;\n        }\n\n        if (type === \"characterData\") {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && targetDOM.nodeType === DOM_TEXT_TYPE && $isTextNode(targetNode) && targetNode.isAttached()) {\n            handleTextMutation( // $FlowFixMe: nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode);\n          }\n        } else if (type === \"childList\") {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && node === null && (addedDOM.nodeName !== \"BR\" || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (removedDOM.nodeName === \"BR\" && isManagedLineBreak(removedDOM, targetDOM, editor)) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.__children;\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM.nodeName === \"BR\" && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n\n        observer.takeRecords();\n      }\n\n      const selection = $getSelection() || getLastSelection(editor);\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents()) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\n\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations(editor, mutations, observer);\n  }\n}\n\nfunction initMutationObserver(editor) {\n  initTextEntryListener();\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations(editor, mutations, observer);\n  });\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass Point {\n  constructor(key, offset, type) {\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      aNode = aNode.getDescendantByIndex(aOffset);\n    }\n\n    if ($isElementNode(bNode)) {\n      bNode = bNode.getDescendantByIndex(bOffset);\n    }\n\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n\n    return aNode.isBefore(bNode);\n  }\n\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n\n    return node;\n  }\n\n  set(key, offset, type) {\n    const selection = $getSelection();\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n\n      if (selection !== null && (selection.anchor === this || selection.focus === this)) {\n        selection.dirty = true;\n      }\n    }\n  }\n\n}\n\nfunction $createPoint(key, offset, type) {\n  // $FlowFixMe: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point, node) {\n  const key = node.__key;\n  let offset = point.offset;\n  let type = \"element\";\n\n  if ($isTextNode(node)) {\n    type = \"text\";\n    const textContentLength = node.getTextContentSize();\n\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  }\n\n  point.set(key, offset, type);\n}\n\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else if ($isTextNode(node)) {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(start, end, format) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  } // Transfer the element point to a text point.\n\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, \"text\");\n  }\n\n  start.set(textNode.__key, 0, \"text\");\n}\n\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key; // $FlowFixMe: internal utility function\n\n  point.offset = offset; // $FlowFixMe: internal utility function\n\n  point.type = type;\n}\n\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n  }\n\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n\n  add(key) {\n    this.dirty = true;\n\n    this._nodes.add(key);\n  }\n\n  delete(key) {\n    this.dirty = true;\n\n    this._nodes.delete(key);\n  }\n\n  clear() {\n    this.dirty = true;\n\n    this._nodes.clear();\n  }\n\n  has(key) {\n    return this._nodes.has(key);\n  }\n\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  getNodes() {\n    const objects = this._nodes;\n    const nodes = [];\n\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = \"\";\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\n\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\n\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n  }\n\n  is(selection) {\n    if (!$isGridSelection(selection)) {\n      return false;\n    }\n\n    return this.gridKey === selection.gridKey && this.anchor.is(this.focus);\n  }\n\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n  }\n\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n\n  isCollapsed() {\n    return false;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n\n    if (!anchorCellNode) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focus.key);\n\n    if (!focusCellNode) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n\n  getNodes() {\n    const nodes = new Set();\n    const {\n      fromX,\n      fromY,\n      toX,\n      toY\n    } = this.getShape();\n    const gridNode = $getNodeByKey(this.gridKey);\n\n    if (!$isGridNode(gridNode)) {\n      {\n        throw Error(`getNodes: expected to find GridNode`);\n      }\n    }\n\n    nodes.add(gridNode);\n    const gridRowNodes = gridNode.getChildren();\n\n    for (let r = fromY; r <= toY; r++) {\n      const gridRowNode = gridRowNodes[r];\n      nodes.add(gridRowNode);\n\n      if (!$isGridRowNode(gridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n\n      const gridCellNodes = gridRowNode.getChildren();\n\n      for (let c = fromX; c <= toX; c++) {\n        const gridCellNode = gridCellNodes[c];\n\n        if (!$isGridCellNode(gridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n\n        nodes.add(gridCellNode);\n        const children = gridCellNode.getChildren();\n\n        while (children.length > 0) {\n          const child = children.shift();\n          nodes.add(child);\n\n          if ($isElementNode(child)) {\n            children.unshift(...child.getChildren());\n          }\n        }\n      }\n    }\n\n    return Array.from(nodes);\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = \"\";\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\n\nfunction $isGridSelection(x) {\n  return x instanceof GridSelection;\n}\n\nclass RangeSelection {\n  constructor(anchor, focus, format) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n  }\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  getNodes() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = anchor.getNode();\n    let lastNode = focus.getNode();\n\n    if ($isElementNode(firstNode)) {\n      firstNode = firstNode.getDescendantByIndex(anchor.offset);\n    }\n\n    if ($isElementNode(lastNode)) {\n      lastNode = lastNode.getDescendantByIndex(focus.offset);\n    }\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && (firstNode.getChildrenSize() > 0 || firstNode.excludeFromCopy())) {\n        return [];\n      }\n\n      return [firstNode];\n    }\n\n    return firstNode.getNodesBetween(lastNode);\n  }\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, \"text\");\n    $setPointValues(this.focus, focusNode.__key, focusOffset, \"text\");\n    this.dirty = true;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n\n    if (nodes.length === 0) {\n      return \"\";\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = \"\";\n    let prevWasElement = true;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += \"\\n\";\n        }\n\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n\n          if (node === firstNode) {\n            if (node === lastNode) {\n              text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n\n    return textContent;\n  }\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n  }\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    return new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format);\n  }\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  insertRawText(text) {\n    const parts = text.split(/\\r?\\n/);\n\n    if (parts.length === 1) {\n      this.insertText(text);\n    } else {\n      const nodes = [];\n      const length = parts.length;\n\n      for (let i = 0; i < length; i++) {\n        const part = parts[i];\n\n        if (part !== \"\") {\n          nodes.push($createTextNode(part));\n        }\n\n        if (i !== length - 1) {\n          nodes.push($createLineBreakNode());\n        }\n      }\n\n      this.insertNodes(nodes);\n    }\n  }\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n\n    if (isBefore && anchor.type === \"element\") {\n      $transferStartingElementPointToTextPoint(anchor, focus, format);\n    } else if (!isBefore && focus.type === \"element\") {\n      $transferStartingElementPointToTextPoint(focus, anchor, format);\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter())) {\n      let nextSibling = firstNode.getNextSibling();\n\n      if (!$isTextNode(nextSibling) || $isTokenOrInertOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n\n      if (text !== \"\") {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore())) {\n      let prevSibling = firstNode.getPreviousSibling();\n\n      if (!$isTextNode(prevSibling) || $isTokenOrInertOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n\n      prevSibling.select();\n      firstNode = prevSibling;\n\n      if (text !== \"\") {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== \"\") {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText(\"\");\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n\n    if (selectedNodesLength === 1) {\n      if ($isTokenOrInert(firstNode)) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n\n      const firstNodeFormat = firstNode.getFormat();\n\n      if (startOffset === endOffset && firstNodeFormat !== format) {\n        if (firstNode.getTextContent() === \"\") {\n          firstNode.setFormat(format);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.select();\n\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n\n          if (textNode.isComposing() && this.anchor.type === \"text\") {\n            this.anchor.offset -= text.length;\n          }\n\n          return;\n        }\n      }\n\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n\n      if (firstNode.getTextContent() === \"\") {\n        firstNode.remove();\n      } else if (firstNode.isComposing() && this.anchor.type === \"text\") {\n        // When composing, we need to adjust the anchor offset so that\n        // we correctly replace that right range.\n        this.anchor.offset -= text.length;\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      const lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow(); // Handle mutations to the last node.\n\n      if (endPoint.type === \"text\" && (endOffset !== 0 || lastNode.getTextContent() === \"\") || endPoint.type === \"element\" && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !$isTokenOrInert(lastNode) && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n\n          lastNode = lastNode.spliceText(0, endOffset, \"\");\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // If the last element is an \"inline\" element, don't move it's text nodes to the first node.\n      // Instead, preserve the \"inline\" element's children and append to the first element.\n\n      if (!lastElement.canBeEmpty() && firstElement !== lastElement) {\n        firstElement.append(lastElement);\n      } else {\n        for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n          const lastNodeChild = lastNodeChildren[i];\n\n          if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n            break;\n          }\n\n          if (lastNodeChild.isAttached()) {\n            if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastNode)) {\n              if (!firstAndLastElementsAreEqual) {\n                firstNode.insertAfter(lastNodeChild);\n              }\n            } else {\n              lastNodeChild.remove();\n            }\n          }\n        }\n\n        if (!firstAndLastElementsAreEqual) {\n          // Check if we have already moved out all the nodes of the\n          // last parent, and if so, traverse the parent tree and mark\n          // them all as being able to deleted too.\n          let parent = lastElement;\n          let lastRemovedParent = null;\n\n          while (parent !== null) {\n            const children = parent.getChildren();\n            const childrenLength = children.length;\n\n            if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n              markedNodeKeysForKeep.delete(parent.__key);\n              lastRemovedParent = parent;\n            }\n\n            parent = parent.getParent();\n          }\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n\n      if (!$isTokenOrInert(firstNode)) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n\n        if (firstNode.getTextContent() === \"\") {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === \"text\") {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  removeText() {\n    this.insertText(\"\");\n  }\n\n  formatText(formatType) {\n    // TODO I wonder if this methods use selection.extract() instead?\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const focusOffset = focus.offset;\n    let firstNextFormat = 0;\n    let firstNodeTextLength = firstNode.getTextContent().length;\n\n    for (let i = 0; i < selectedNodes.length; i++) {\n      const selectedNode = selectedNodes[i];\n\n      if ($isTextNode(selectedNode)) {\n        firstNextFormat = selectedNode.getFormatFlags(formatType, null);\n        break;\n      }\n    }\n\n    let anchorOffset = anchor.offset;\n    let startOffset;\n    let endOffset;\n    const isBefore = anchor.isBefore(focus);\n    startOffset = isBefore ? anchorOffset : focusOffset;\n    endOffset = isBefore ? focusOffset : anchorOffset; // This is the case where the user only selected the very end of the\n    // first node so we don't want to include it in the formatting change.\n\n    if (startOffset === firstNode.getTextContentSize()) {\n      const nextSibling = firstNode.getNextSibling();\n\n      if ($isTextNode(nextSibling)) {\n        // we basically make the second node the firstNode, changing offsets accordingly\n        anchorOffset = 0;\n        startOffset = 0;\n        firstNode = nextSibling;\n        firstNodeTextLength = nextSibling.getTextContent().length;\n        firstNextFormat = firstNode.getFormatFlags(formatType, null);\n      }\n    } // This is the case where we only selected a single node\n\n\n    if (firstNode.is(lastNode)) {\n      if ($isTextNode(firstNode)) {\n        if (anchor.type === \"element\" && focus.type === \"element\") {\n          firstNode.setFormat(firstNextFormat);\n          firstNode.select(startOffset, endOffset);\n          this.format = firstNextFormat;\n          return;\n        }\n\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n        if (startOffset === endOffset) {\n          return;\n        } // The entire node is selected, so just format it\n\n\n        if (startOffset === 0 && endOffset === firstNodeTextLength) {\n          firstNode.setFormat(firstNextFormat);\n          firstNode.select(startOffset, endOffset);\n        } else {\n          // ndoe is partially selected, so split it into two nodes\n          // adnd style the selected one.\n          const splitNodes = firstNode.splitText(startOffset, endOffset);\n          const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n          replacement.setFormat(firstNextFormat);\n          replacement.select(0, endOffset - startOffset);\n        }\n\n        this.format = firstNextFormat;\n      } // multiple nodes selected.\n\n    } else {\n      if ($isTextNode(firstNode)) {\n        if (startOffset !== 0) {\n          // the entire first node isn't selected, so split it\n          [, firstNode] = firstNode.splitText(startOffset);\n          startOffset = 0;\n        }\n\n        firstNode.setFormat(firstNextFormat);\n      }\n\n      let lastNextFormat = firstNextFormat;\n\n      if ($isTextNode(lastNode)) {\n        lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n        const lastNodeText = lastNode.getTextContent();\n        const lastNodeTextLength = lastNodeText.length; // if the offset is 0, it means no actual characters are selected,\n        // so we skip formatting the last node altogether.\n\n        if (endOffset !== 0) {\n          // if the entire last node isn't selected, split it\n          if (endOffset !== lastNodeTextLength) {\n            [lastNode] = lastNode.splitText(endOffset);\n          }\n\n          lastNode.setFormat(lastNextFormat);\n        }\n      } // deal with all the nodes in between\n\n\n      for (let i = 1; i < lastIndex; i++) {\n        const selectedNode = selectedNodes[i];\n        const selectedNodeKey = selectedNode.__key;\n\n        if ($isTextNode(selectedNode) && selectedNodeKey !== firstNode.__key && selectedNodeKey !== lastNode.__key && !selectedNode.isToken()) {\n          const selectedNextFormat = selectedNode.getFormatFlags(formatType, lastNextFormat);\n          selectedNode.setFormat(selectedNextFormat);\n        }\n      }\n    }\n  }\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n\n    if (anchor.type === \"element\") {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootNode(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if ($isTokenOrInert(anchorNode)) {\n        // Do nothing if we're inside an immutable/inert node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNodeInserted = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node)) {\n        // -----\n        // Heuristics for the replacment or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n\n          const firstDescendant = node.getFirstDescendant();\n\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n\n            const children = element.getChildren();\n            const childrenLength = children.length;\n\n            if ($isElementNode(target)) {\n              for (let s = 0; s < childrenLength; s++) {\n                lastNodeInserted = children[s];\n                target.append(lastNodeInserted);\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                lastNodeInserted = children[s];\n                target.insertAfter(lastNodeInserted);\n              }\n\n              target = target.getParentOrThrow();\n            }\n\n            element.remove();\n            didReplaceOrMerge = true;\n\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootNode(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n\n      didReplaceOrMerge = false;\n\n      if ($isElementNode(target)) {\n        lastNodeInserted = node;\n\n        if ($isDecoratorNode(node) && node.isTopLevel()) {\n          target = target.insertAfter(node);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n\n            target = node;\n          } else {\n            target = target.insertAfter(node);\n          }\n        }\n      } else if (!$isElementNode(node) || $isDecoratorNode(target) && target.isTopLevel()) {\n        lastNodeInserted = node;\n        target = target.insertAfter(node);\n      } else {\n        target = node.getParentOrThrow(); // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNodeInserted) ? lastNodeInserted : target.getLastDescendant();\n\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          lastChild.select();\n        } else {\n          lastChild.selectNext();\n        }\n      }\n\n      if (siblings.length !== 0) {\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n\n          if ($isElementNode(target) && !$isElementNode(sibling)) {\n            target.append(sibling);\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n\n    return true;\n  }\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n\n    if (anchor.type === \"text\") {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n\n      if ($isRootNode(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n\n        if (child !== null) {\n          child.insertBefore(paragraph);\n        } else {\n          currentElement.append(paragraph);\n        }\n\n        return;\n      }\n\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n\n    const nodesToMoveLength = nodesToMove.length;\n\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      currentElement.getParentOrThrow().insertBefore($createParagraphNode());\n      return;\n    }\n\n    const newElement = currentElement.insertNewAfter(this);\n\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n\n          firstChild = nodeToMove;\n        }\n      }\n\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n\n    if (anchor.type === \"element\") {\n      const element = anchor.getNode();\n\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode)) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n\n      return [firstNode];\n    }\n\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n\n    return selectedNodes;\n  }\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === \"move\"; // Handle the selection movement around decorators.\n\n    const possibleNode = $getDecoratorNode(focus, isBackward);\n\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n\n          if (!isBackward) {\n            offset++;\n          }\n        }\n\n        focus.set(elementKey, offset, \"element\");\n\n        if (collapse) {\n          anchor.set(elementKey, offset, \"element\");\n        }\n\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, \"text\");\n\n        if (collapse) {\n          anchor.set(siblingKey, offset, \"text\");\n        }\n\n        return;\n      }\n    }\n\n    const domSelection = getDOMSelection(); // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n    $moveNativeSelection(domSelection, alter, isBackward ? \"backward\" : \"forward\", granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n      // $FlowFixMe[incompatible-call]\n\n      this.applyDOMRange(range); // Because a range works on start and end, we might need to flip\n      // the anchor and focus points to match what the DOM has, not what\n      // the range has specifically.\n\n      if (!collapse && (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset)) {\n        $swapPoints(this);\n      }\n    }\n  }\n\n  deleteCharacter(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n\n      if (!isBackward && ( // Delete forward handle case\n      anchor.type === \"element\" && // $FlowFixMe: always an element node\n      anchor.offset === anchorNode.getChildrenSize() || anchor.type === \"text\" && anchor.offset === anchorNode.getTextContentSize())) {\n        const nextSibling = anchorNode.getNextSibling() || anchorNode.getParentOrThrow().getNextSibling();\n\n        if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {\n          return;\n        }\n      }\n\n      this.modify(\"extend\", isBackward, \"character\");\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === \"text\" ? focus.getNode() : null;\n        anchorNode = anchor.type === \"text\" ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === \"element\" ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n\n    this.removeText();\n  }\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify(\"extend\", isBackward, \"lineboundary\");\n    }\n\n    this.removeText();\n  }\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify(\"extend\", isBackward, \"word\");\n    }\n\n    this.removeText();\n  }\n\n}\n\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\n\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n\n  if (point.type === \"text\") {\n    return offset;\n  } // $FlowFixMe: cast\n\n\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\n\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (anchor.type === \"element\" && focus.type === \"element\" && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\n\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n}\n\nfunction $moveNativeSelection(domSelection, alter, direction, granularity) {\n  // $FlowFixMe[prop-missing]\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (anchorNode === focusNode && anchor.type === \"text\" && focus.type === \"text\") {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\n\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/\\s/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n\n      break;\n    }\n  }\n\n  const nextTextContent = split.join(\" \");\n\n  if (nextTextContent === \"\") {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\n\nfunction internalResolveSelectionPoint(dom, offset, lastPoint) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n\n    const childDOM = childNodes[resolvedOffset];\n    resolvedNode = getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = child.getParentOrThrow();\n          }\n        }\n\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, \"element\");\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n\n  return $createPoint(resolvedNode.__key, resolvedOffset, \"text\");\n}\n\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize(); // $FlowFixMe: intentional\n\n        point.type = \"element\";\n      } else if ($isTextNode(prevSibling) && !prevSibling.isInert()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0; // $FlowFixMe: intentional\n\n      point.type = \"element\";\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getNextSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\n\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === \"text\" && focus.type === \"text\") {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n\n    const editor = getActiveEditor();\n\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\n\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null);\n\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null);\n\n  if (resolvedFocusPoint === null) {\n    return null;\n  } // Handle normalization of selection when it is at the boundaries.\n\n\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0);\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\n\nfunction $createEmptyRangeSelection() {\n  const anchor = $createPoint(\"root\", 0, \"element\");\n  const focus = $createPoint(\"root\", 0, \"element\");\n  return new RangeSelection(anchor, focus, 0);\n}\n\nfunction $createEmptyObjectSelection() {\n  return new NodeSelection(new Set());\n}\n\nfunction $createEmptyGridSelection() {\n  const anchor = $createPoint(\"root\", 0, \"element\");\n  const focus = $createPoint(\"root\", 0, \"element\");\n  return new GridSelection(\"root\", anchor, focus);\n}\n\nfunction getActiveEventType() {\n  const event = window.event;\n  return event && event.type;\n}\n\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection();\n\n  if ($isNodeSelection(lastSelection) || $isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\n\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n  const eventType = getActiveEventType();\n  const isSelectionChange = eventType === \"selectionchange\";\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === \"beforeinput\" || eventType === \"compositionstart\" || eventType === \"compositionend\" || eventType === \"click\" && window.event.detail === 3 || eventType == null);\n  console.log(eventType == null, getIsProcesssingMutations());\n  console.log(\"internalCreateRangeSelection\", {\n    useDOMSelection,\n    eventType\n  });\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format);\n}\n\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\n\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\n\nfunction internalCreateSelectionFromParse(parsedSelection) {\n  if (parsedSelection !== null) {\n    if (parsedSelection.type === \"range\") {\n      return new RangeSelection($createPoint(parsedSelection.anchor.key, parsedSelection.anchor.offset, parsedSelection.anchor.type), $createPoint(parsedSelection.focus.key, parsedSelection.focus.offset, parsedSelection.focus.type), 0);\n    } else if (parsedSelection.type === \"node\") {\n      return new NodeSelection(new Set(parsedSelection.nodes));\n    } else if (parsedSelection.type === \"grid\") {\n      return new GridSelection(parsedSelection.gridKey, $createPoint(parsedSelection.anchor.key, parsedSelection.anchor.offset, parsedSelection.anchor.type), $createPoint(parsedSelection.focus.key, parsedSelection.focus.offset, parsedSelection.focus.type));\n    }\n  }\n\n  return null;\n}\n\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n\n    if (nodeOffset <= selectionOffset) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, \"element\");\n      focus.set(parentKey, newSelectionOffset, \"element\"); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n\n    return;\n  } // Multiple nodes selected. We shift or redimension selection\n\n\n  const isBackward = selection.isBackward();\n  const firstPoint = isBackward ? focus : anchor;\n  const firstPointNode = firstPoint.getNode();\n  const lastPoint = isBackward ? anchor : focus;\n  const lastPointNode = lastPoint.getNode();\n\n  if (parentNode.is(firstPointNode)) {\n    const firstPointOffset = firstPoint.offset;\n\n    if (nodeOffset <= firstPointOffset) {\n      firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), \"element\");\n    }\n  }\n\n  if (parentNode.is(lastPointNode)) {\n    const lastPointOffset = lastPoint.offset;\n\n    if (nodeOffset <= lastPointOffset) {\n      lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), \"element\");\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, \"text\");\n      focus.set(child.__key, newOffset, \"text\");\n    }\n\n    return;\n  }\n\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, \"text\");\n    }\n  }\n\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      focus.set(child.__key, newOffset, \"text\");\n    }\n  }\n}\n\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === \"text\") {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n\n    if (focus.type === \"text\") {\n      const focusNode = focus.getNode();\n\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\n\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = \"text\";\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = \"element\";\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n\n      if ($isTextNode(nextSibling)) {\n        type = \"text\";\n      } else if ($isElementNode(nextSibling)) {\n        type = \"element\";\n      }\n    }\n  }\n\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n\n    point.set(parent.__key, offset, \"element\");\n  }\n}\n\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === \"text\") {\n    point.key = key;\n\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n\n  if (parent === null) {\n    return;\n  }\n\n  const selection = $getSelection();\n  let selectionMoved = false;\n\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  }\n\n  const writableParent = parent.getWritable();\n  const parentChildren = writableParent.__children;\n  const index = parentChildren.indexOf(key);\n\n  if (index === -1) {\n    {\n      throw Error(`Node is not a child of its parent`);\n    }\n  }\n\n  internalMarkSiblingsAsDirty(nodeToRemove);\n  parentChildren.splice(index, 1);\n  const writableNodeToRemove = nodeToRemove.getWritable();\n  writableNodeToRemove.__parent = null;\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  }\n\n  if (!preserveEmptyParent && parent !== null && !$isRootNode(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n\n  if (parent !== null && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\n\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n\n  return node;\n}\n\nclass LexicalNode {\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  static clone(data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    $setNodeKey(this, key); // Ensure custom nodes implement required methods.\n\n    {\n      const proto = Object.getPrototypeOf(this);\n      [\"getType\", \"clone\"].forEach(method => {\n        if (!proto.constructor.hasOwnProperty(method)) {\n          console.warn(`${this.constructor.name} must implement static \"${method}\" method`);\n        }\n      });\n\n      if (this.__type !== \"root\") {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n\n  getType() {\n    return this.__type;\n  }\n\n  isAttached() {\n    let nodeKey = this.__key;\n\n    while (nodeKey !== null) {\n      if (nodeKey === \"root\") {\n        return true;\n      }\n\n      const node = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n\n      nodeKey = node.__parent;\n    }\n\n    return false;\n  }\n\n  isSelected() {\n    const selection = $getSelection();\n\n    if (selection == null) {\n      return false;\n    }\n\n    const selectedNodeKeys = new Set(selection.getNodes().map(n => n.__key));\n    const isSelected = selectedNodeKeys.has(this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n\n    if ($isRangeSelection(selection) && selection.anchor.type === \"element\" && selection.focus.type === \"element\" && selection.anchor.key === selection.focus.key && selection.anchor.offset === selection.focus.offset) {\n      return false;\n    }\n\n    return isSelected;\n  }\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return -1;\n    }\n\n    const children = parent.__children;\n    return children.indexOf(this.__key);\n  }\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n\n    if (parent === null) {\n      return null;\n    }\n\n    return $getNodeByKey(parent);\n  }\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n\n    return parent;\n  }\n\n  getTopLevelElement() {\n    let node = this;\n\n    while (node !== null) {\n      const parent = node.getParent();\n\n      if ($isRootNode(parent) && $isElementNode(node)) {\n        return node;\n      }\n\n      node = parent;\n    }\n\n    return null;\n  }\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n\n    return parent;\n  }\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n\n  getPreviousSibling() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return null;\n    }\n\n    const children = parent.__children;\n    const index = children.indexOf(this.__key);\n\n    if (index <= 0) {\n      return null;\n    }\n\n    return $getNodeByKey(children[index - 1]);\n  }\n\n  getPreviousSiblings() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return [];\n    }\n\n    const children = parent.__children;\n    const index = children.indexOf(this.__key);\n    return children.slice(0, index).map(childKey => $getNodeByKeyOrThrow(childKey));\n  }\n\n  getNextSibling() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return null;\n    }\n\n    const children = parent.__children;\n    const childrenLength = children.length;\n    const index = children.indexOf(this.__key);\n\n    if (index >= childrenLength - 1) {\n      return null;\n    }\n\n    return $getNodeByKey(children[index + 1]);\n  }\n\n  getNextSiblings() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return [];\n    }\n\n    const children = parent.__children;\n    const index = children.indexOf(this.__key);\n    return children.slice(index + 1).map(childKey => $getNodeByKeyOrThrow(childKey));\n  }\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n\n    const bSet = new Set(b);\n\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n\n    return null;\n  }\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n\n    return this.__key === object.__key;\n  }\n\n  isBefore(targetNode) {\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexA = parent.__children.indexOf(node.__key);\n        break;\n      }\n\n      node = parent;\n    }\n\n    node = targetNode;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexB = parent.__children.indexOf(node.__key);\n        break;\n      }\n\n      node = parent;\n    }\n\n    return indexA < indexB;\n  }\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n\n    if (key === targetNode.__key) {\n      return false;\n    }\n\n    let node = targetNode;\n\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n\n      node = node.getParent();\n    }\n\n    return false;\n  }\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    let dfsAncestor = null;\n\n    while (true) {\n      const key = node.__key;\n\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n\n      if (node === targetNode) {\n        break;\n      }\n\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n\n      if (child !== null) {\n        if (dfsAncestor === null) {\n          dfsAncestor = node;\n        }\n\n        node = child;\n        continue;\n      }\n\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n\n      const parent = node.getParentOrThrow();\n\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n\n      if (parent === targetNode) {\n        break;\n      }\n\n      let parentSibling = null;\n      let ancestor = parent;\n\n      if (parent.is(dfsAncestor)) {\n        dfsAncestor = null;\n      }\n\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n\n        if (ancestor !== null) {\n          if (ancestor.is(dfsAncestor)) {\n            dfsAncestor = null;\n          }\n\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n\n      node = parentSibling;\n    }\n\n    if (!isBefore) {\n      nodes.reverse();\n    }\n\n    return nodes;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  } // TODO remove this and move to TextNode\n\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n\n    if (latest === null) {\n      {\n        throw Error(`getLatest: node not found`);\n      }\n    }\n\n    return latest;\n  } // $FlowFixMe this is LexicalNode\n\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n\n    const constructor = latestNode.constructor;\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__children = Array.from(latestNode.__children);\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      const marks = latestNode.__marks;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n      mutableNode.__marks = marks === null ? marks : Array.from(marks);\n    }\n\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode); // $FlowFixMe this is LexicalNode\n\n    return mutableNode;\n  } // TODO remove this completely\n\n\n  getTextContent(includeInert, includeDirectionless) {\n    return \"\";\n  } // TODO remove this completely\n\n\n  getTextContentSize(includeInert, includeDirectionless) {\n    return this.getTextContent(includeInert, includeDirectionless).length;\n  } // View\n\n\n  createDOM(config, editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  updateDOM(prevNode, dom, config) {\n    // $FlowFixMe: TODO\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  exportDOM(editor) {\n    if ($isDecoratorNode(this)) {\n      const element = editor.getElementByKey(this.getKey());\n      return {\n        element: element ? element.cloneNode() : null\n      };\n    }\n\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  static importDOM() {\n    return null;\n  } // Setters and mutators\n\n\n  remove(preserveEmptyParent) {\n    errorOnReadOnly();\n    removeNode(this, true, preserveEmptyParent);\n  }\n\n  replace(replaceWith) {\n    errorOnReadOnly();\n    const toReplaceKey = this.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    removeFromParent(writableReplaceWith);\n    const newParent = this.getParentOrThrow();\n    const writableParent = newParent.getWritable();\n    const children = writableParent.__children;\n    const index = children.indexOf(this.__key);\n    const newKey = writableReplaceWith.__key;\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    children.splice(index, 0, newKey);\n    writableReplaceWith.__parent = newParent.__key;\n    removeNode(this, false);\n    internalMarkSiblingsAsDirty(writableReplaceWith);\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(newKey);\n    }\n\n    return writableReplaceWith;\n  }\n\n  insertAfter(nodeToInsert) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    const oldIndex = nodeToInsert.getIndexWithinParent();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n\n    if (oldParent !== null) {\n      removeFromParent(writableNodeToInsert);\n\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === \"element\" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === \"element\" && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const children = writableParent.__children;\n    const index = children.indexOf(writableSelf.__key);\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    children.splice(index + 1, 0, insertKey);\n    internalMarkSiblingsAsDirty(writableNodeToInsert);\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, \"element\");\n      }\n\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, \"element\");\n      }\n    }\n\n    return nodeToInsert;\n  }\n\n  insertBefore(nodeToInsert) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    removeFromParent(writableNodeToInsert);\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const children = writableParent.__children;\n    const index = children.indexOf(writableSelf.__key);\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    children.splice(index, 0, insertKey);\n    internalMarkSiblingsAsDirty(writableNodeToInsert);\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index);\n    }\n\n    return nodeToInsert;\n  }\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n\n    if (nextSibling === null) {\n      return parent.select();\n    }\n\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n\n    return nextSibling.select(anchorOffset, focusOffset);\n  } // Proxy to mark something as dirty\n\n\n  markDirty() {\n    this.getWritable();\n  }\n\n}\n\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not previously registered on the editor. You can use register your custom nodes.`);\n    }\n  }\n\n  const editorKlass = registeredNode.klass;\n\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key); // ensure custom nodes implement required methods\n\n    {\n      const proto = Object.getPrototypeOf(this);\n      [\"decorate\"].forEach(method => {\n        if (!proto.hasOwnProperty(method)) {\n          console.warn(`${this.constructor.name} must implement \"${method}\" method`);\n        }\n      });\n    }\n  }\n\n  decorate(editor) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n\n  isIsolated() {\n    return false;\n  }\n\n  isTopLevel() {\n    return false;\n  }\n\n}\n\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass ElementNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n    this.__children = [];\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n\n  getChildren() {\n    const self = this.getLatest();\n    const children = self.__children;\n    const childrenNodes = [];\n\n    for (let i = 0; i < children.length; i++) {\n      const childNode = $getNodeByKey(children[i]);\n\n      if (childNode !== null) {\n        childrenNodes.push(childNode);\n      }\n    }\n\n    return childrenNodes;\n  }\n\n  getChildrenKeys() {\n    return this.getLatest().__children;\n  }\n\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__children.length;\n  }\n\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n\n  isLastChild() {\n    const self = this.getLatest();\n    const parent = self.getParentOrThrow();\n    return parent.getLastChild() === self;\n  }\n\n  getAllTextNodes(includeInert) {\n    const textNodes = [];\n    const self = this.getLatest();\n    const children = self.__children;\n\n    for (let i = 0; i < children.length; i++) {\n      const childNode = $getNodeByKey(children[i]);\n\n      if ($isTextNode(childNode) && (includeInert || !childNode.isInert())) {\n        textNodes.push(childNode);\n      } else if ($isElementNode(childNode)) {\n        const subChildrenNodes = childNode.getAllTextNodes(includeInert);\n        textNodes.push(...subChildrenNodes);\n      }\n    }\n\n    return textNodes;\n  }\n\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getLastDescendant() {\n    let node = this.getLastChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength === 0) {\n      return this;\n    } // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode;\n    }\n\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode;\n  }\n\n  getFirstChild() {\n    const self = this.getLatest();\n    const children = self.__children;\n    const childrenLength = children.length;\n\n    if (childrenLength === 0) {\n      return null;\n    }\n\n    return $getNodeByKey(children[0]);\n  }\n\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n\n    return firstChild;\n  }\n\n  getLastChild() {\n    const self = this.getLatest();\n    const children = self.__children;\n    const childrenLength = children.length;\n\n    if (childrenLength === 0) {\n      return null;\n    }\n\n    return $getNodeByKey(children[childrenLength - 1]);\n  }\n\n  getChildAtIndex(index) {\n    const self = this.getLatest();\n    const children = self.__children;\n    const key = children[index];\n\n    if (key === undefined) {\n      return null;\n    }\n\n    return $getNodeByKey(key);\n  }\n\n  getTextContent(includeInert, includeDirectionless) {\n    let textContent = \"\";\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent(includeInert, includeDirectionless);\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n\n    return textContent;\n  }\n\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n\n  hasFormat(type) {\n    const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  } // Mutators\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n\n    const key = this.__key;\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, \"element\", \"element\");\n    } else {\n      selection.anchor.set(key, anchorOffset, \"element\");\n      selection.focus.set(key, focusOffset, \"element\");\n      selection.dirty = true;\n    }\n\n    return selection;\n  }\n\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n\n    return this.select(0, 0);\n  }\n\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n\n    return this.select();\n  }\n\n  clear() {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n\n  append(...nodesToAppend) {\n    errorOnReadOnly();\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n\n  setDirection(direction) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n\n  setFormat(type) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__format = ELEMENT_TYPE_TO_FORMAT[type];\n    return this;\n  }\n\n  setIndent(indentLevel) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n\n  splice(start, deleteCount, nodesToInsert) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const writableSelfChildren = writableSelf.__children;\n    const nodesToInsertLength = nodesToInsert.length;\n    const nodesToInsertKeys = []; // Remove nodes to insert from their previous parent\n\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      const writableNodeToInsert = nodeToInsert.getWritable();\n\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attemtping to append self`);\n        }\n      }\n\n      removeFromParent(writableNodeToInsert); // Set child parent to self\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      const newKey = writableNodeToInsert.__key;\n      nodesToInsertKeys.push(newKey);\n    } // Mark range edges siblings as dirty\n\n\n    const nodeBeforeRange = this.getChildAtIndex(start - 1);\n\n    if (nodeBeforeRange) {\n      internalMarkNodeAsDirty(nodeBeforeRange);\n    }\n\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n\n    if (nodeAfterRange) {\n      internalMarkNodeAsDirty(nodeAfterRange);\n    } // Remove defined range of children\n\n\n    let nodesToRemoveKeys; // Using faster push when only appending nodes\n\n    if (start === writableSelfChildren.length) {\n      writableSelfChildren.push(...nodesToInsertKeys);\n      nodesToRemoveKeys = [];\n    } else {\n      nodesToRemoveKeys = writableSelfChildren.splice(start, deleteCount, ...nodesToInsertKeys);\n    } // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n\n        const isPointRemoved = point => {\n          let node = point.getNode();\n\n          while (node) {\n            const nodeKey = node.__key;\n\n            if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n              return true;\n            }\n\n            node = node.getParent();\n          }\n\n          return false;\n        };\n\n        const {\n          anchor,\n          focus\n        } = selection;\n\n        if (isPointRemoved(anchor)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n\n        if (isPointRemoved(focus)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Unlink removed nodes from current parent\n\n\n        const nodesToRemoveKeysLength = nodesToRemoveKeys.length;\n\n        for (let i = 0; i < nodesToRemoveKeysLength; i++) {\n          const nodeToRemove = $getNodeByKey(nodesToRemoveKeys[i]);\n\n          if (nodeToRemove != null) {\n            const writableNodeToRemove = nodeToRemove.getWritable();\n            writableNodeToRemove.__parent = null;\n          }\n        } // Cleanup if node can't be empty\n\n\n        if (writableSelfChildren.length === 0 && !this.canBeEmpty() && !$isRootNode(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  } // These are intended to be extends for specific element heuristics.\n\n\n  insertNewAfter(selection) {\n    return null;\n  }\n\n  canInsertTab() {\n    return false;\n  }\n\n  canIndent() {\n    return true;\n  }\n\n  collapseAtStart(selection) {\n    return false;\n  }\n\n  excludeFromCopy() {\n    return false;\n  }\n\n  canExtractContents() {\n    return true;\n  }\n\n  canReplaceWith(replacement) {\n    return true;\n  }\n\n  canInsertAfter(node) {\n    return true;\n  }\n\n  canBeEmpty() {\n    return true;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  isInline() {\n    return false;\n  }\n\n  canMergeWith(node) {\n    return false;\n  }\n\n}\n\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass RootNode extends ElementNode {\n  static getType() {\n    return \"root\";\n  }\n\n  static clone() {\n    return new RootNode();\n  }\n\n  constructor() {\n    super(\"root\");\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n\n  getTextContent(includeInert, includeDirectionless) {\n    const cachedText = this.__cachedText;\n\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null && (!includeInert || includeDirectionless !== false)) {\n        return cachedText;\n      }\n    }\n\n    return super.getTextContent(includeInert, includeDirectionless);\n  }\n\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n\n  insertAfter(node) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n\n    return super.append(...nodesToAppend);\n  }\n\n  toJSON() {\n    return {\n      __children: this.__children,\n      __dir: this.__dir,\n      __format: this.__format,\n      __indent: this.__indent,\n      __key: \"root\",\n      __parent: null,\n      __type: \"root\"\n    };\n  }\n\n}\n\nfunction $createRootNode() {\n  return new RootNode();\n}\n\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\n\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([[\"root\", $createRootNode()]]));\n}\n\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n\n  toJSON(space) {\n    const selection = this._selection;\n    return {\n      _nodeMap: Array.from(this._nodeMap.entries()),\n      _selection: $isRangeSelection(selection) ? {\n        anchor: {\n          key: selection.anchor.key,\n          offset: selection.anchor.offset,\n          type: selection.anchor.type\n        },\n        focus: {\n          key: selection.focus.key,\n          offset: selection.focus.offset,\n          type: selection.focus.type\n        },\n        type: \"range\"\n      } : $isNodeSelection(selection) ? {\n        nodes: Array.from(selection._nodes),\n        type: \"node\"\n      } : $isGridSelection(selection) ? {\n        anchor: {\n          key: selection.anchor.key,\n          offset: selection.anchor.offset,\n          type: selection.anchor.type\n        },\n        focus: {\n          key: selection.focus.key,\n          offset: selection.focus.offset,\n          type: selection.focus.type\n        },\n        gridKey: selection.gridKey,\n        type: \"grid\"\n      } : null\n    };\n  }\n\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return \"linebreak\";\n  }\n\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  getTextContent() {\n    return \"\\n\";\n  }\n\n  createDOM() {\n    return document.createElement(\"br\");\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      br: node => ({\n        conversion: convertLineBreakElement,\n        priority: 0\n      })\n    };\n  }\n\n}\n\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\n\nfunction $createLineBreakNode() {\n  return new LineBreakNode();\n}\n\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction simpleDiffWithCursor(a, b, cursor) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0; // number of same characters counting from left\n\n  let right = 0; // number of same characters counting from right\n  // Iterate left to the right until we find a changed character\n  // First iteration considers the current cursor position\n\n  while (left < aLength && left < bLength && a[left] === b[left] && left < cursor) {\n    left++;\n  } // Iterate right to the left until we find a changed character\n\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  } // Try to iterate left further to the right without caring about the current cursor position\n\n\n  while (right + left < aLength && right + left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  return {\n    index: left,\n    insert: b.slice(left, bLength - right),\n    remove: aLength - left - right\n  };\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return \"code\";\n  }\n\n  if (format & IS_SUBSCRIPT) {\n    return \"sub\";\n  }\n\n  if (format & IS_SUPERSCRIPT) {\n    return \"sup\";\n  }\n\n  return null;\n}\n\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return \"strong\";\n  }\n\n  if (format & IS_ITALIC) {\n    return \"em\";\n  }\n\n  return \"span\";\n}\n\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, \"base\");\n\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n\n  classNames = getCachedClassNameArray(textClassNames, \"underlineStrikethrough\");\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    // $FlowFixMe: expected cast here\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === \"underline\" || key === \"strikethrough\")) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n\n          continue;\n        }\n\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === \"underline\" || key === \"strikethrough\") {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(nextText, dom, node) {\n  // $FlowFixMe: first node is always text\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? ZERO_WIDTH_CHAR : \"\";\n  const text = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) if (isComposing) {\n      const [index, remove, insert] = diffComposedText(nodeValue, text);\n\n      if (remove !== 0) {\n        firstChild.deleteData(index, remove);\n      }\n\n      firstChild.insertData(index, insert);\n    } else {\n      firstChild.nodeValue = text;\n    }\n  }\n}\n\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nfunction updateTextMarks(textNode, marks, offset, delCount, size) {\n  for (let i = 0; i < marks.length; i++) {\n    const {\n      id,\n      start,\n      end\n    } = marks[i];\n    let newStart = start;\n    let newEnd = end;\n\n    if (newStart !== null && newStart >= offset) {\n      if (offset + delCount >= newStart) {\n        newStart = offset + delCount;\n      }\n\n      newStart += size - delCount;\n    }\n\n    if (newEnd !== null && newEnd >= offset) {\n      if (offset + delCount >= newEnd) {\n        newEnd = offset;\n      }\n\n      newEnd += size - delCount;\n    }\n\n    if (newStart !== start || newEnd !== end) {\n      if (newStart === null && newEnd === null || newStart !== null && newEnd !== null && newStart >= newEnd) {\n        textNode.deleteMark(id);\n      } else {\n        textNode.setMark(id, newStart, newEnd);\n      }\n    }\n  }\n}\n\nclass TextNode extends LexicalNode {\n  static getType() {\n    return \"text\";\n  }\n\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = \"\";\n    this.__mode = 0;\n    this.__detail = 0;\n    this.__marks = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getMark(id) {\n    const self = this.getLatest();\n    const marks = self.__marks;\n\n    if (marks !== null) {\n      for (let i = 0; i < marks.length; i++) {\n        const mark = marks[i];\n\n        if (mark.id === id) {\n          return mark;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n\n  isInert() {\n    const self = this.getLatest();\n    return self.__mode === IS_INERT;\n  }\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  isSimpleText() {\n    return this.__type === \"text\" && this.__mode === 0;\n  }\n\n  getTextContent(includeInert, includeDirectionless) {\n    if (!includeInert && this.isInert() || includeDirectionless === false && this.isDirectionless()) {\n      return \"\";\n    }\n\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n\n    if (style !== \"\") {\n      dom.style.cssText = style;\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // $FlowFixMe: should always be an element\n      const prevInnerDOM = dom.firstChild;\n\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n\n    let innerDOM = dom;\n\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        // $FlowFixMe: should always be an element\n        innerDOM = dom.firstChild;\n\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      \"#text\": node => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: node => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      em: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: node => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  } // Mutators\n\n\n  selectionTransform(prevSelection, nextSelection) {}\n\n  setFormat(format) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__format = format;\n    return self;\n  }\n\n  setStyle(style) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n\n  toggleDirectionless() {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  toggleUnmergeable() {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  setMark(id, start, end) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    let marks = self.__marks;\n    let found = false;\n\n    if (marks === null) {\n      self.__marks = marks = [];\n    }\n\n    const nextMark = {\n      end,\n      id,\n      start\n    };\n    {\n      Object.freeze(nextMark);\n    }\n\n    for (let i = 0; i < marks.length; i++) {\n      const prevMark = marks[i];\n\n      if (prevMark.id === id) {\n        found = true;\n        marks.splice(i, 1, nextMark);\n        break;\n      }\n    }\n\n    if (!found) {\n      marks.push(nextMark);\n    }\n  }\n\n  deleteMark(id) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    const marks = self.__marks;\n\n    if (marks === null) {\n      return;\n    }\n\n    for (let i = 0; i < marks.length; i++) {\n      const prevMark = marks[i];\n\n      if (prevMark.id === id) {\n        marks.splice(i, 1);\n        break;\n      }\n    }\n\n    if (marks.length === 0) {\n      self.__marks = null;\n    }\n  }\n\n  setMode(type) {\n    errorOnReadOnly();\n    const mode = TEXT_MODE_TO_TYPE[type];\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  setTextContent(text) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const marks = writableSelf.__marks;\n\n    if (marks !== null) {\n      const selection = $getSelection();\n      let cursorOffset = text.length;\n\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const anchor = selection.anchor;\n\n        if (anchor.key === this.__key) {\n          cursorOffset = anchor.offset;\n        }\n      }\n\n      const diff = simpleDiffWithCursor(writableSelf.__text, text, cursorOffset);\n      this.spliceText(diff.index, diff.remove, diff.insert);\n    } else {\n      writableSelf.__text = text;\n    }\n\n    return writableSelf;\n  }\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n\n    if (typeof text === \"string\") {\n      const lastOffset = text.length;\n\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, \"text\", \"text\");\n    } else {\n      const compositionKey = $getCompositionKey();\n\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n\n    return selection;\n  }\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n\n    if (index < 0) {\n      index = handledTextLength + index;\n\n      if (index < 0) {\n        index = 0;\n      }\n    }\n\n    const selection = $getSelection();\n\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    const marks = writableSelf.__marks;\n\n    if (marks !== null) {\n      updateTextMarks(writableSelf, marks, offset, delCount, handledTextLength);\n    }\n\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = \"\";\n\n    for (let i = 0; i < textLength; i++) {\n      if (string !== \"\" && offsetsSet.has(i)) {\n        parts.push(string);\n        string = \"\";\n      }\n\n      string += textContent[i];\n    }\n\n    if (string !== \"\") {\n      parts.push(string);\n    }\n\n    const partsLength = parts.length;\n\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    const parentKey = parent.__key;\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    const marks = self.__marks;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__parent = parentKey;\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      writableNode.__marks = marks;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (anchor.key === key && anchor.type === \"text\" && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n\n        if (focus.key === key && focus.type === \"text\" && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n\n      textSize = nextTextSize;\n      sibling.__parent = parentKey;\n      splitNodes.push(sibling);\n    }\n\n    if (marks !== null) {\n      for (let i = 0; i < marks.length; i++) {\n        const {\n          id,\n          start,\n          end\n        } = marks[i];\n        let foundStart = false;\n        let foundEnd = false;\n        let partSize = 0;\n\n        for (let s = 0; s < partsLength; s++) {\n          const textNode = splitNodes[s];\n          const nextPartSize = partSize + parts[s].length;\n          const nextStart = !foundStart && start !== null && nextPartSize > start - (start === 0 ? 1 : 0) ? start - partSize : null;\n          const nextEnd = !foundEnd && end !== null && nextPartSize >= end ? end - partSize : null;\n\n          if (nextStart !== null || nextEnd !== null) {\n            if (nextStart !== null) {\n              foundStart = true;\n            }\n\n            if (nextEnd !== null) {\n              foundEnd = true;\n            }\n\n            textNode.setMark(id, nextStart, nextEnd);\n\n            if (foundStart && foundEnd) {\n              break;\n            }\n          } else {\n            textNode.deleteMark(id);\n          }\n\n          partSize = nextPartSize;\n        }\n      }\n    } // Insert the nodes into the parent's children\n\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const writableParentChildren = writableParent.__children;\n    const insertionIndex = writableParentChildren.indexOf(key);\n    const splitNodesKeys = splitNodes.map(splitNode => splitNode.__key);\n\n    if (hasReplacedSelf) {\n      writableParentChildren.splice(insertionIndex, 0, ...splitNodesKeys);\n      this.remove();\n    } else {\n      writableParentChildren.splice(insertionIndex, 1, ...splitNodesKeys);\n    }\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n\n    return splitNodes;\n  }\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n\n    const targetText = target.__text;\n    const targetTextLength = targetText.length;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n\n    const marks = target.getLatest().__marks;\n\n    if (marks !== null) {\n      updateTextMarks(writableSelf, marks, isBefore ? targetTextLength : 0, 0, textLength);\n    }\n\n    target.remove();\n    return writableSelf;\n  }\n\n  isTextEntity() {\n    return false;\n  }\n\n}\n\nfunction convertSpanElement(domNode) {\n  // $FlowFixMe[incompatible-type] domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === \"700\";\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && hasBoldFontWeight) {\n        lexicalNode.toggleFormat(\"bold\");\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertBringAttentionToElement(domNode) {\n  // $FlowFixMe[incompatible-type] domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === \"normal\";\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat(\"bold\");\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertTextDOMNode(domNode) {\n  return {\n    node: $createTextNode(domNode.textContent)\n  };\n}\n\nconst nodeNameToTextFormat = {\n  em: \"italic\",\n  i: \"italic\",\n  strong: \"bold\",\n  u: \"underline\"\n};\n\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode)) {\n        lexicalNode.toggleFormat(format);\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction $createTextNode(text = \"\") {\n  return new TextNode(text);\n}\n\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return \"paragraph\";\n  }\n\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n\n  createDOM(config) {\n    const dom = document.createElement(\"p\");\n    const classNames = getCachedClassNameArray(config.theme, \"paragraph\");\n\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      if (this.getTextContentSize() === 0) {\n        element.append(document.createElement(\"br\"));\n      }\n    }\n\n    return {\n      element\n    };\n  } // Mutation\n\n\n  insertNewAfter() {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === \"\") {\n      const nextSibling = this.getNextSibling();\n\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n\n      const prevSibling = this.getPreviousSibling();\n\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction convertParagraphElement() {\n  return {\n    node: $createParagraphNode()\n  };\n}\n\nfunction $createParagraphNode() {\n  return new ParagraphNode();\n}\n\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n\n  editor._cloneNotNeeded.clear();\n\n  editor._dirtyLeaves = new Set();\n\n  editor._dirtyElements.clear();\n\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = \"\";\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = \"\";\n    keyNodeMap.set(\"root\", nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n\n    if (handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM();\n\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const namespace = config.namespace || createUID();\n  const theme = config.theme || {};\n  const parentEditor = config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isReadOnly = config.readOnly || false;\n  const registeredNodes = new Map();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const klass = nodes[i];\n    const type = klass.getType();\n    registeredNodes.set(type, {\n      klass,\n      transforms: new Set()\n    });\n  } // klass: Array<Class<LexicalNode>>\n  // $FlowFixMe: use our declared type instead\n\n\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError, initializeConversionCache(registeredNodes), isReadOnly);\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\n\nclass LexicalEditor {\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, readOnly) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      mutation: new Map(),\n      readonly: new Set(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconcilation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = generateRandomKey();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._readOnly = false;\n  }\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerReadOnlyListener(listener) {\n    const listenerSetOrMap = this._listeners.readonly;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${command} not found in command map`);\n      }\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  registerNodeTransform( // There's no Flow-safe way to preserve the T in Transform<T>, but <T: LexicalNode> in the\n  // declaration below guarantees these are LexicalNodes.\n  klass, listener) {\n    const type = klass.getType();\n\n    const registeredNode = this._nodes.get(type);\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    markAllNodesAsDirty(this, type);\n    return () => {\n      transforms.delete(listener);\n    };\n  }\n\n  hasNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const klass = nodes[i];\n      const type = klass.getType();\n\n      if (!this._nodes.has(type)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  getDecorators() {\n    return this._decorators;\n  }\n\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const style = nextRootElement.style;\n        style.userSelect = \"text\";\n        style.whiteSpace = \"pre-wrap\";\n        style.wordBreak = \"break-word\";\n        nextRootElement.setAttribute(\"data-lexical-editor\", \"true\");\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add(\"history-merge\");\n\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n      }\n\n      triggerListeners(\"root\", this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  getEditorState() {\n    return this._editorState;\n  }\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    commitPendingUpdates(this);\n  }\n\n  parseEditorState(stringifiedEditorState) {\n    const parsedEditorState = JSON.parse(stringifiedEditorState);\n    return parseEditorState(parsedEditorState, this);\n  }\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  focus(callbackFn) {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute(\"autocapitalize\", \"off\");\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          root.selectEnd();\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute(\"autocapitalize\");\n\n          if (callbackFn) {\n            callbackFn();\n          }\n        }\n      });\n    }\n  }\n\n  blur() {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection();\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n\n  isReadOnly() {\n    return this._readOnly;\n  }\n\n  setReadOnly(readOnly) {\n    this._readOnly = readOnly;\n    triggerListeners(\"readonly\", this, true, readOnly);\n  }\n\n  toJSON() {\n    return {\n      editorState: this._editorState\n    };\n  }\n\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nconst VERSION = \"0.2.5\";\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\nclass GridCellNode extends ElementNode {\n  constructor(colSpan, key) {\n    super(key);\n  }\n\n}\n\nfunction $isGridCellNode(node) {\n  return node instanceof GridCellNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass GridNode extends ElementNode {}\n\nfunction $isGridNode(node) {\n  return node instanceof GridNode;\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n */\n\n\nclass GridRowNode extends ElementNode {}\n\nfunction $isGridRowNode(node) {\n  return node instanceof GridRowNode;\n}\n\nexports.$createGridSelection = $createEmptyGridSelection;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeFromParse = $createNodeFromParse;\nexports.$createNodeSelection = $createEmptyObjectSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createEmptyRangeSelection;\nexports.$createTextNode = $createTextNode;\nexports.$getDecoratorNode = $getDecoratorNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isGridCellNode = $isGridCellNode;\nexports.$isGridNode = $isGridNode;\nexports.$isGridRowNode = $isGridRowNode;\nexports.$isGridSelection = $isGridSelection;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.GridCellNode = GridCellNode;\nexports.GridNode = GridNode;\nexports.GridRowNode = GridRowNode;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TEXT_COMMAND = INSERT_TEXT_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.VERSION = VERSION;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\n\n//# sourceURL=webpack://Lexical/./deps/lexical/Lexical.dev.js?");

/***/ }),

/***/ "./deps/lexical/Lexical.js":
/*!*********************************!*\
  !*** ./deps/lexical/Lexical.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst Lexical =  true ? __webpack_require__(/*! ./Lexical.dev.js */ \"./deps/lexical/Lexical.dev.js\") : undefined;\nmodule.exports = Lexical;\n\n//# sourceURL=webpack://Lexical/./deps/lexical/Lexical.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.lexical = __webpack_require__(/*! lexical */ \"./deps/lexical/Lexical.js\");\nexports.LexicalPlainText = __webpack_require__(/*! @lexical/plain-text */ \"./deps/@lexical/plain-text/LexicalPlainText.js\");\n\n//# sourceURL=webpack://Lexical/./main.js?");

/***/ }),

/***/ "./node_modules/@lexical/clipboard/LexicalClipboard.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./deps/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst IGNORE_TAGS = new Set(['STYLE']);\nfunction getHtmlContent(editor) {\n  const selection$1 = lexical.$getSelection();\n\n  if (selection$1 == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection$1) && selection$1.isCollapsed() || selection$1.getNodes().length === 0) {\n    return null;\n  }\n\n  const state = selection.$cloneContents(selection$1);\n  return $convertSelectedLexicalContentToHtml(editor, selection$1, state);\n}\nfunction $convertSelectedLexicalNodeToHTMLElement(editor, selection, node) {\n  let nodeToConvert = node;\n\n  if (lexical.$isRangeSelection(selection) || lexical.$isGridSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = node.is(anchorNode);\n    const isFocus = node.is(focusNode);\n\n    if (lexical.$isTextNode(node) && (isAnchor || isFocus)) {\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isBackward = selection.isBackward();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = node.is(isBackward ? focusNode : anchorNode);\n      const isLast = node.is(isBackward ? anchorNode : focusNode);\n\n      if (isSame) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = node.splitText(startOffset, endOffset);\n        nodeToConvert = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        const splitNodes = node.splitText(offset);\n        nodeToConvert = offset === 0 ? splitNodes[0] : splitNodes[1];\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        const splitNodes = node.splitText(offset);\n        nodeToConvert = splitNodes[0];\n      }\n    }\n  }\n\n  const {\n    element,\n    after\n  } = nodeToConvert.exportDOM(editor);\n  if (!element) return null;\n  const children = lexical.$isElementNode(nodeToConvert) ? nodeToConvert.getChildren() : [];\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n\n    if (childNode.isSelected()) {\n      const newElement = $convertSelectedLexicalNodeToHTMLElement(editor, selection, childNode);\n      if (newElement) element.append(newElement);\n    }\n  }\n\n  return after ? after.call(nodeToConvert, element) : element;\n}\nfunction $convertSelectedLexicalContentToHtml(editor, selection, state) {\n  const container = document.createElement('div');\n\n  for (let i = 0; i < state.range.length; i++) {\n    const nodeKey = state.range[i];\n    const node = lexical.$getNodeByKey(nodeKey);\n\n    if (node) {\n      const element = $convertSelectedLexicalNodeToHTMLElement(editor, selection, node);\n\n      if (element) {\n        // It might be the case that the node is an element node\n        // and we're not directly selecting it, but we are selecting\n        // some of its children. So we'll need to extract that out\n        // separately.\n        if (node.isSelected()) {\n          container.append(element);\n        } else {\n          let childNode = element.firstChild;\n\n          while (childNode != null) {\n            const nextSibling = childNode.nextSibling;\n            container.append(childNode);\n            childNode = nextSibling;\n          }\n        }\n      }\n    }\n  }\n\n  return container.innerHTML;\n}\nfunction $getLexicalContent(editor) {\n  const selection$1 = lexical.$getSelection();\n\n  if (selection$1 !== null) {\n    const namespace = editor._config.namespace;\n    const state = selection.$cloneContents(selection$1);\n    return JSON.stringify({\n      namespace,\n      state\n    });\n  }\n\n  return null;\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalNodesString = dataTransfer.getData('application/x-lexical-editor');\n  const isSelectionInsideOfGrid = lexical.$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.$isGridCellNode(n)) !== null;\n\n  if (lexicalNodesString) {\n    const namespace = editor._config.namespace;\n\n    try {\n      const lexicalClipboardData = JSON.parse(lexicalNodesString);\n\n      if (lexicalClipboardData.namespace === namespace) {\n        const nodeRange = lexicalClipboardData.state;\n        const nodes = $generateNodes(nodeRange);\n\n        if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.$isGridNode(nodes[0])) {\n          $mergeGridNodesStrategy(nodes, selection, false, editor);\n          return;\n        }\n\n        $basicInsertStrategy(nodes, selection, true);\n        return;\n      }\n    } catch (e) {// Malformed, missing nodes..\n    }\n  }\n\n  const textHtmlMimeType = 'text/html';\n  const htmlString = dataTransfer.getData(textHtmlMimeType);\n\n  if (htmlString) {\n    const parser = new DOMParser();\n    const dom = parser.parseFromString(htmlString, textHtmlMimeType);\n    const nodes = $generateNodesFromDOM(dom, editor);\n\n    if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.$isGridNode(nodes[0])) {\n      $mergeGridNodesStrategy(nodes, selection, false, editor);\n      return;\n    }\n\n    $basicInsertStrategy(nodes, selection, false);\n    return;\n  }\n\n  $insertDataTransferForPlainText(dataTransfer, selection);\n}\n\nfunction $basicInsertStrategy(nodes, selection, isFromLexical) {\n  let nodesToInsert;\n\n  if (!isFromLexical) {\n    // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n    const topLevelBlocks = [];\n    let currentBlock = null;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (!lexical.$isElementNode(node) || node.isInline()) {\n        if (currentBlock === null) {\n          currentBlock = lexical.$createParagraphNode();\n          topLevelBlocks.push(currentBlock);\n        }\n\n        if (currentBlock !== null) {\n          currentBlock.append(node);\n        }\n      } else {\n        topLevelBlocks.push(node);\n        currentBlock = null;\n      }\n    }\n\n    nodesToInsert = topLevelBlocks;\n  } else {\n    nodesToInsert = nodes;\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(nodesToInsert);\n  } else if (lexical.$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...nodesToInsert);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.$isGridNode(n));\n\n  if (!lexical.$isGridCellNode(gridCellNode) || !lexical.$isGridRowNode(gridRowNode) || !lexical.$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND);\n  }\n}\n\nfunction $generateNodes(nodeRange) {\n  const {\n    range,\n    nodeMap\n  } = nodeRange;\n  const parsedNodeMap = new Map(nodeMap);\n  const nodes = [];\n\n  for (let i = 0; i < range.length; i++) {\n    const key = range[i];\n    const parsedNode = parsedNodeMap.get(key);\n\n    if (parsedNode !== undefined) {\n      const node = lexical.$createNodeFromParse(parsedNode, parsedNodeMap);\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    cachedConversions.forEach(cachedConversion => {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null) {\n        if (currentConversion === null || currentConversion.priority < domConversion.priority) {\n          currentConversion = domConversion;\n        }\n      }\n    });\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, forChildMap, currentLexicalNode));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nfunction $generateNodesFromDOM(dom, editor) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.getHtmlContent = getHtmlContent;\n\n\n//# sourceURL=webpack://Lexical/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/clipboard/LexicalClipboard.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalClipboard =  true ? __webpack_require__(/*! ./LexicalClipboard.dev.js */ \"./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\") : undefined\nmodule.exports = LexicalClipboard;\n\n//# sourceURL=webpack://Lexical/./node_modules/@lexical/clipboard/LexicalClipboard.js?");

/***/ }),

/***/ "./node_modules/@lexical/selection/LexicalSelection.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./deps/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst cssToStyles = new Map();\n\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor;\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    clone.__children = Array.from(latest.__children);\n    clone.__format = latest.__format;\n    clone.__indent = latest.__indent;\n    clone.__dir = latest.__dir;\n  } else if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    const marks = latest.__marks;\n    clone.__format = latest.__format;\n    clone.__style = latest.__style;\n    clone.__mode = latest.__mode;\n    clone.__detail = latest.__detail;\n    clone.__marks = marks === null ? null : Array.from(marks);\n  } // $FlowFixMe\n\n\n  return clone;\n}\n\nfunction $getIndexFromPossibleClone(node, parent, nodeMap) {\n  const parentClone = nodeMap.get(parent.getKey());\n\n  if (lexical.$isElementNode(parentClone)) {\n    return parentClone.__children.indexOf(node.getKey());\n  }\n\n  return node.getIndexWithinParent();\n}\n\nfunction $getParentAvoidingExcludedElements(node) {\n  let parent = node.getParent();\n\n  while (parent !== null && parent.excludeFromCopy()) {\n    parent = parent.getParent();\n  }\n\n  return parent;\n}\n\nfunction $copyLeafNodeBranchToRoot(leaf, startingOffset, endingOffset, isLeftSide, range, nodeMap) {\n  let node = leaf;\n  let offset = startingOffset;\n\n  while (node !== null) {\n    const parent = $getParentAvoidingExcludedElements(node);\n\n    if (parent === null) {\n      break;\n    }\n\n    if (!lexical.$isElementNode(node) || !node.excludeFromCopy()) {\n      const key = node.getKey();\n      let clone = nodeMap.get(key);\n      const needsClone = clone === undefined;\n\n      if (needsClone) {\n        clone = $cloneWithProperties(node);\n        nodeMap.set(key, clone);\n      }\n\n      if (lexical.$isTextNode(clone) && !clone.isSegmented() && !clone.isToken()) {\n        clone.__text = clone.__text.slice(isLeftSide ? offset : 0, isLeftSide ? endingOffset : offset);\n      } else if (lexical.$isElementNode(clone)) {\n        clone.__children = clone.__children.slice(isLeftSide ? offset : 0, isLeftSide ? undefined : (offset || 0) + 1);\n      }\n\n      if (lexical.$isRootNode(parent)) {\n        if (needsClone) {\n          // We only want to collect a range of top level nodes.\n          // So if the parent is the root, we know this is a top level.\n          range.push(key);\n        }\n\n        break;\n      }\n    }\n\n    offset = $getIndexFromPossibleClone(node, parent, nodeMap);\n    node = parent;\n  }\n}\n\nfunction errGetLatestOnClone() {\n  {\n    throw Error(`getLatest() on clone node`);\n  }\n}\n\nfunction $cloneContents(selection) {\n  const clone = $cloneContentsImpl(selection);\n\n  {\n    const nodeMap = clone.nodeMap;\n\n    for (let i = 0; i < nodeMap.length; i++) {\n      const node = nodeMap[i][1]; // $FlowFixMe[method-unbinding]\n\n      if (node.getLatest === errGetLatestOnClone) {\n        continue;\n      }\n\n      Object.setPrototypeOf(node, Object.create(Object.getPrototypeOf(node), {\n        getLatest: {\n          configurable: true,\n          enumerable: true,\n          value: errGetLatestOnClone,\n          writable: true\n        }\n      }));\n    }\n  }\n\n  return clone;\n}\n\nfunction $cloneContentsImpl(selection) {\n  if (lexical.$isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n    const nodes = selection.getNodes();\n\n    if (nodes.length === 0) {\n      return {\n        nodeMap: [],\n        range: []\n      };\n    } // Check if we can use the parent of the nodes, if the\n    // parent can't be empty, then it's important that we\n    // also copy that element node along with its children.\n\n\n    let nodesLength = nodes.length;\n    const firstNode = nodes[0];\n    const firstNodeParent = firstNode.getParent();\n\n    if (firstNodeParent !== null && (!firstNodeParent.canBeEmpty() || lexical.$isRootNode(firstNodeParent))) {\n      const parentChildren = firstNodeParent.__children;\n      const parentChildrenLength = parentChildren.length;\n\n      if (parentChildrenLength === nodesLength) {\n        let areTheSame = true;\n\n        for (let i = 0; i < parentChildren.length; i++) {\n          if (parentChildren[i] !== nodes[i].__key) {\n            areTheSame = false;\n            break;\n          }\n        }\n\n        if (areTheSame) {\n          nodesLength++;\n          nodes.push(firstNodeParent);\n        }\n      }\n    }\n\n    const lastNode = nodes[nodesLength - 1];\n    const isBefore = anchor.isBefore(focus);\n    const nodeMap = new Map();\n    const range = [];\n    const isOnlyText = lexical.$isTextNode(firstNode) && nodesLength === 1; // Do first node to root\n\n    $copyLeafNodeBranchToRoot(firstNode, isBefore ? anchorOffset : focusOffset, isOnlyText ? isBefore ? focusOffset : anchorOffset : undefined, true, range, nodeMap); // Copy all nodes between\n\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      const key = node.getKey();\n\n      if (!nodeMap.has(key) && (!lexical.$isElementNode(node) || !node.excludeFromCopy())) {\n        const clone = $cloneWithProperties(node);\n\n        if (lexical.$isRootNode(node.getParent())) {\n          range.push(node.getKey());\n        }\n\n        if (key !== 'root') {\n          nodeMap.set(key, clone);\n        }\n      }\n    } // Do last node to root\n\n\n    $copyLeafNodeBranchToRoot(lastNode, isOnlyText ? undefined : isBefore ? focusOffset : anchorOffset, undefined, false, range, nodeMap);\n    return {\n      nodeMap: Array.from(nodeMap.entries()),\n      range\n    };\n  } else if (lexical.$isGridSelection(selection)) {\n    const nodeMap = selection.getNodes().map(node => {\n      const nodeKey = node.getKey();\n      const clone = $cloneWithProperties(node);\n      return [nodeKey, clone];\n    });\n    return {\n      nodeMap,\n      range: [selection.gridKey]\n    };\n  }\n\n  {\n    throw Error(`TODO`);\n  }\n}\n\nfunction getStyleObjectFromCSS(css) {\n  return cssToStyles.get(css) || null;\n}\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\nfunction $patchNodeStyle(node, patch) {\n  const prevStyles = getStyleObjectFromCSS(node.getStyle());\n  const newStyles = prevStyles ? { ...prevStyles,\n    ...patch\n  } : patch;\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  node.setStyle(newCSSText);\n  cssToStyles.set(newCSSText, newStyles);\n}\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  let startOffset;\n  let endOffset;\n  const isBefore = anchor.isBefore(focus);\n  startOffset = isBefore ? anchorOffset : focusOffset;\n  endOffset = isBefore ? focusOffset : anchorOffset; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (startOffset === firstNode.getTextContentSize()) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (firstNode.is(lastNode)) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchNodeStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchNodeStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode)) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        [, firstNode] = firstNode.splitText(startOffset);\n        startOffset = 0;\n      }\n\n      $patchNodeStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // if the entire last node isn't selected, split it\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchNodeStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchNodeStyle(selectedNode, patch);\n      }\n    }\n  }\n}\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same font size.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n    lastOffset = lastNode.getChildrenSize();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootNode(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.__children.length === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n\nfunction $wrapLeafNodesInElements(selection, createElement, wrappingElement) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootNode(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedLeafNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedLeafNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedLeafNodes.add(child.getKey());\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      elements.push(createElement());\n      node.remove();\n    }\n  }\n\n  if (wrappingElement) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  } // If our target is the root, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n\n  if (lexical.$isRootNode(target)) {\n    const firstChild = target.getFirstChild();\n\n    if (lexical.$isElementNode(firstChild)) {\n      target = firstChild;\n    }\n\n    if (firstChild === null) {\n      if (wrappingElement) {\n        target.append(wrappingElement);\n      } else {\n        for (let i = 0; i < elements.length; i++) {\n          const element = elements[i];\n          target.append(element);\n        }\n      }\n    } else {\n      if (wrappingElement) {\n        firstChild.insertBefore(wrappingElement);\n      } else {\n        for (let i = 0; i < elements.length; i++) {\n          const element = elements[i];\n          firstChild.insertBefore(element);\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    const clonedSelection = prevSelection.clone();\n    clonedSelection.dirty = true;\n    lexical.$setSelection(clonedSelection);\n  } else {\n    selection.dirty = true;\n  }\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getDecoratorNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated();\n}\n\nexports.$cloneContents = $cloneContents;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$wrapLeafNodesInElements = $wrapLeafNodesInElements;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\n\n\n//# sourceURL=webpack://Lexical/./node_modules/@lexical/selection/LexicalSelection.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/selection/LexicalSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalSelection =  true ? __webpack_require__(/*! ./LexicalSelection.dev.js */ \"./node_modules/@lexical/selection/LexicalSelection.dev.js\") : undefined\nmodule.exports = LexicalSelection;\n\n//# sourceURL=webpack://Lexical/./node_modules/@lexical/selection/LexicalSelection.js?");

/***/ }),

/***/ "./node_modules/@lexical/utils/LexicalUtils.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./deps/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (className != null && typeof className === 'string') {\n      element.classList.add(...className.split(' '));\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    element.classList.remove(...className.split(' '));\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let node_ = node;\n  let depth = 0;\n\n  while ((node_ = node_.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return parent;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.mergeRegister = mergeRegister;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n\n\n//# sourceURL=webpack://Lexical/./node_modules/@lexical/utils/LexicalUtils.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/utils/LexicalUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalUtils =  true ? __webpack_require__(/*! ./LexicalUtils.dev.js */ \"./node_modules/@lexical/utils/LexicalUtils.dev.js\") : undefined\nmodule.exports = LexicalUtils;\n\n//# sourceURL=webpack://Lexical/./node_modules/@lexical/utils/LexicalUtils.js?");

/***/ })

/******/ });
});